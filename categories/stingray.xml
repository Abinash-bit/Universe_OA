<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Universe OpenAstronomy (Posts about stingray)</title><link>http://openastronomy.org/Universe_OA/</link><description></description><atom:link href="http://openastronomy.org/Universe_OA/categories/stingray.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Tue, 13 Jun 2023 01:11:21 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>GSoC Week 1 Progress Update</title><link>http://openastronomy.org/Universe_OA/posts/2023/06/20230608_0729_pupperemeritus/</link><dc:creator>pupper emeritus</dc:creator><description>&lt;h2&gt;


&lt;!-- TEASER_END --&gt;
Brief
&lt;/h2&gt;

&lt;p&gt;Week 1 has been quite eventful with me creating a Lomb Scargle Fourier Transform function and get a working class for Lomb Scargle Cross Spectrum and Power Spectrum.&lt;/p&gt;

&lt;p&gt;I inherited my LS cross spectrum from the regular cross spectrum class. Had to rewrite the &lt;code&gt;constructor&lt;/code&gt;, &lt;code&gt;initial_checks&lt;/code&gt; , &lt;code&gt;make_crossspectrum&lt;/code&gt;, &lt;code&gt;_make_auxil_pds&lt;/code&gt; and &lt;code&gt;_initialize_empty&lt;/code&gt;. And also wrote a new &lt;code&gt;_ls_cross&lt;/code&gt; method which just returns the frequencies and cross spectra for given light curves and it is an internal function only to be used by the class.&lt;/p&gt;

&lt;p&gt;The original slow implementation has been completed. I am still working on the fast version.&lt;/p&gt;

&lt;p&gt;As this is not a project that can be completed in a bunch of small PRs, I will push to a single PR which will be merged after completion of the project. The following draft PR is the one to which I will be pushing to. &lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/StingraySoftware/stingray/pull/737/"&gt;https://github.com/StingraySoftware/stingray/pull/737/&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;


Details
&lt;/h2&gt;

&lt;p&gt;The following are the APIs for the classes&lt;/p&gt;

&lt;h3&gt;


Cross Spectrum
&lt;/h3&gt;



&lt;div class="highlight js-code-highlight"&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;Make a cross spectrum from an unevenly sampled light curve.
You can also make an empty :class:`Crossspectrum` object to populate with your
own Fourier-transformed data (this can sometimes be useful when making
binned power spectra).

Parameters
----------
data1: :class:`stingray.Lightcurve` or :class:`stingray.events.EventList`, optional, default ``None``
The dataset for the first channel/band of interest.

data2: :class:`stingray.Lightcurve` or :class:`stingray.events.EventList`, optional, default ``None``
The dataset for the second, or "reference", band.

norm: {``frac``, ``abs``, ``leahy``, ``none``}, default ``none``
The normalization of the (real part of the) cross spectrum.

power_type: string, optional, default ``real``
Parameter to choose among complete, real part and magnitude of the cross spectrum.

fullspec: boolean, optional, default ``False``
If False, keep only the positive frequencies, or if True, keep all of them .

Other Parameters
----------------
dt: float
The time resolution of the light curve. Only needed when constructing
light curves in the case where ``data1``, ``data2`` are
:class:`EventList` objects

skip_checks: bool
Skip initial checks, for speed or other reasons (you need to trust your
inputs!)

min_freq : float
Minimum frequency to take the Lomb-Scargle Fourier Transform

max_freq: float
Maximum frequency to take the Lomb-Scargle Fourier Transform

df : float
The time resolution of the light curve. Only needed where ``data1``, ``data2`` are

method : str
The method to be used by the Lomb-Scargle Fourier Transformation function. `fast`
and `slow` are the alloowed values. Default is `fast`. fast uses the optimized Press
and Rybicki O(n*log(n))

Attributes
----------
freq: numpy.ndarray
The array of mid-bin frequencies that the Fourier transform samples

power: numpy.ndarray
The array of cross spectra (complex numbers)

power_err: numpy.ndarray
The uncertainties of ``power``.
An approximation for each bin given by ``power_err= power/sqrt(m)``.
Where ``m`` is the number of power averaged in each bin (by frequency
binning, or averaging more than one spectra). Note that for a single
realization (``m=1``) the error is equal to the power.

df: float
The frequency resolution

m: int
The number of averaged cross-spectra amplitudes in each bin.

n: int
The number of data points/time bins in one segment of the light
curves.

k: array of int
The rebinning scheme if the object has been rebinned otherwise is set to 1.

nphots1: float
The total number of photons in light curve 1

nphots2: float
The total number of photons in light curve 2
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;



&lt;h3&gt;


Power Spectrum
&lt;/h3&gt;



&lt;div class="highlight js-code-highlight"&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;Make a :class:`LombScarglePowerspectrum` (also called periodogram) from a unevenly sampled (binned)
light curve. Periodograms can be normalized by either Leahy normalization,
fractional rms normalization, absolute rms normalization, or not at all.

You can also make an empty :class:`LombScarglePowerspectrum` object to populate with
your own fourier-transformed data (this can sometimes be useful when making
binned power spectra).

Parameters
----------
data: :class:`stingray.lightcurve.Lightcurve` or :class:`stingray.events.EventList` object, optional, default ``None``
The light curve data to be Fourier-transformed.

norm: {"leahy" | "frac" | "abs" | "none" }, optional, default "frac"
The normaliation of the power spectrum to be used. Options are
"leahy", "frac", "abs" and "none", default is "frac".

Other Parameters
----------------
dt: float
The time resolution of the light curve. Only needed when constructing
light curves in the case where ``data`` is a
:class:`EventList` object

skip_checks: bool
Skip initial checks, for speed or other reasons (you need to trust your
inputs!).

min_freq : float
Minimum frequency to take the Lomb-Scargle Fourier Transform

max_freq: float
Maximum frequency to take the Lomb-Scargle Fourier Transform

df : float
The time resolution of the light curve. Only needed where ``data`` is a :class`stingray.Eventlist` object

method : str
The method to be used by the Lomb-Scargle Fourier Transformation function. `fast`
and `slow` are the alloowed values. Default is `fast`. fast uses the optimized Press
and Rybicki O(n*log(n))

Attributes
----------
norm: {"leahy" | "frac" | "abs" | "none" }
The normalization of the power spectrum.

freq: numpy.ndarray
The array of mid-bin frequencies that the Fourier transform samples.

power: numpy.ndarray
The array of normalized squared absolute values of Fourier
amplitudes.

power_err: numpy.ndarray
The uncertainties of ``power``.
An approximation for each bin given by ``power_err= power/sqrt(m)``.
Where ``m`` is the number of power averaged in each bin (by frequency
binning, or averaging power spectra of segments of a light curve).
Note that for a single realization (``m=1``) the error is equal to the
power.

df: float
The frequency resolution.

m: int
The number of averaged powers in each bin.

n: int
The number of data points in the light curve.

nphots: float
The total number of photons in the light curve.
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;</description><category>stingray</category><guid>http://openastronomy.org/Universe_OA/posts/2023/06/20230608_0729_pupperemeritus/</guid><pubDate>Thu, 08 Jun 2023 06:29:01 GMT</pubDate></item><item><title>Community Bonding Period</title><link>http://openastronomy.org/Universe_OA/posts/2023/06/20230601_0311_pupperemeritus/</link><dc:creator>pupper emeritus</dc:creator><description>&lt;h3&gt;


&lt;!-- TEASER_END --&gt;
Brief
&lt;/h3&gt;

&lt;p&gt;Hello everyone this is Sri Guru Datta P.(pupperemeritus). I am extremely excited to get started with my GSoC journey. It has been a dream come true for me.&lt;/p&gt;

&lt;p&gt;Most of the progress in these weeks has been done on the fronts of&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Re-adjusting the proposed schedule : Re-evaluating and taking a closer look at requirements&lt;/li&gt;
&lt;li&gt;Gathering more information required to implement : Been provided reference implementation in MATLAB by Dr. Jeff Scargle himself. And validating the plan and research done during the period of creating the project proposal.&lt;/li&gt;
&lt;li&gt;Had weekly meets to break the ice and communicate more directly through weekly meets with mentors.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;


Environment setup
&lt;/h3&gt;

&lt;p&gt;I had already completed my environment setup earlier in order to make pull requests to stingray. I just followed the documentation.&lt;br&gt;
&lt;a href="https://docs.stingray.science/install.html"&gt;https://docs.stingray.science/install.html&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;


Codebase familiarity
&lt;/h3&gt;

&lt;p&gt;I already had a bit of familiarity with powerspectrum, crossspectrum and bexvar modules as I had worked on various pull requests on them. My mentor advised me to look into multitaper, which I did. It gave me a few ideas on how I could implement this project.&lt;/p&gt;

&lt;h3&gt;


Coding
&lt;/h3&gt;

&lt;p&gt;I had already started a few days early and went ahead and implemented the Lomb-Scargle Fourier Transform which will be the backbone of the power spectrum and cross spectrum. 2 days into the coding period and I also have started coding up the wrapper classes. It turns out to be a very tangled process in order to get every small nook and cranny of the class to work. But I have seemed to get the hang of it.&lt;/p&gt;</description><category>stingray</category><guid>http://openastronomy.org/Universe_OA/posts/2023/06/20230601_0311_pupperemeritus/</guid><pubDate>Thu, 01 Jun 2023 02:11:02 GMT</pubDate></item><item><title>GSoC - Pre Community Bonding</title><link>http://openastronomy.org/Universe_OA/posts/2023/05/20230507_0000_gaurav17joshi/</link><dc:creator>Jash Shah</dc:creator><description>&lt;h3 id="what-is-open-source-and-gsoc"&gt;What is Open-Source and Gsoc?&lt;/h3&gt;
&lt;p&gt;Open source software is software with source code that anyone can inspect, modify, and enhance. There are many institutions and individuals who write open software, mainly for research or free deployment purposes. Mostly these softwares, have only a few maintainers, and multiple people, writing and debugging the code, helps a lot. This is where Google Summer of Code &lt;code class="language-plaintext highlighter-rouge"&gt;GSOC&lt;/code&gt; comes into the picture. It is a global, online program focused on bringing new contributors into open source software development. Many organisations float projects for the developers to take over the summer and Google mediates in the process, while also paying the contributors for their work over the summer.&lt;/p&gt;

&lt;!-- TEASER_END --&gt;
&lt;h3 id="why-gsoc-for-me"&gt;Why GSOC for me?&lt;/h3&gt;
&lt;p&gt;Computer Science and Mathematics are two fields that I find to be most interesting. I first heard of Gsoc, when I was still finding my feet in the vast world of programming and computing. I was instantly sold to the idea of working for an organisation, and writing research code over summer. When I was searching for organisations and their project, I stumbled upon Open Astronomy, and in particular the project &lt;a href="https://openastronomy.org/gsoc/gsoc2023/#/projects?project=searching_for_quasi-periodic_oscillations_with_gaussian_processes"&gt;Searching for Quasi-Periodic Oscillations with Gaussian Processes&lt;/a&gt;, for the Stingray Library. The QPO project was an exceptional opportunity that aligned perfectly with my interests and aspirations. Utilizing the Gaussian Process, a sophisticated and effective mathematical tool for regression and classification problems, the project analyzed astronomical data from some of the universe’s most extreme sources, including quasars and neutron stars - areas of particular interest to me. Given my programming expertise, the project’s requirements were an ideal match, and I was eager to undertake it as a learning experience. Over the course of a month, I worked diligently to secure the project, confident that it was the ideal fit for my skillset and passion.&lt;/p&gt;

&lt;h3 id="my-contribution-experience"&gt;My contribution experience&lt;/h3&gt;
&lt;p&gt;My learnings from Gsoc began even before the project started. I had never worked on an open source package and the experience of making pull requests and getting them merged was very enriching.&lt;/p&gt;

&lt;p&gt;I must also add that through all this, my mentors helped me a lot in my project proposal as well as my code submissions. I would not have been able to make it this for without their help, and their patience in helping out with my amateur mistakes.&lt;/p&gt;</description><category>stingray</category><guid>http://openastronomy.org/Universe_OA/posts/2023/05/20230507_0000_gaurav17joshi/</guid><pubDate>Sat, 06 May 2023 23:00:00 GMT</pubDate></item><item><title>GSoC Blog Zero</title><link>http://openastronomy.org/Universe_OA/posts/2023/05/20230506_2149_pupperemeritus/</link><dc:creator>pupper emeritus</dc:creator><description>&lt;p&gt;This is a test post to check the status of the blog and RSS feed. I am very excited to contribute to Stingray @ Open Astronomy this summer.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;</description><category>stingray</category><guid>http://openastronomy.org/Universe_OA/posts/2023/05/20230506_2149_pupperemeritus/</guid><pubDate>Sat, 06 May 2023 20:49:25 GMT</pubDate></item><item><title>GSoC@Stingray: Final dash! blog#4</title><link>http://openastronomy.org/Universe_OA/posts/2022/09/20220912_1708_mihirtripathi97/</link><dc:creator>Mihirtripathi</dc:creator><description>&lt;p&gt;Hey everyone,&lt;/p&gt;
&lt;p&gt;It is the end of the coding period of GSoC”22. This is going to be my last blog about my project.&lt;/p&gt;
&lt;p&gt;After successfully implementing the bexvar method in Stingray (this &lt;a href="https://github.com/StingraySoftware/stingray/pull/664"&gt;PR&lt;/a&gt;). I and my mentors decided that we can now work to add bexvar as a method to Stingra’s Lightcurve class. This was not a part of my original proposal. The bexvar() method takes lightcurve data in input parameters, so it made sense to provide this facility to users. Stingray’s Lightcurve class facilitates users to create Lightcurve objects and perform several operations useful for time series analysis on them.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;The Lightcurve object is created by providing two arrays ( time and counts) as input parameters. Along with these it also has several other optional parameters specifying relevant lightcurve data. Most of these parameters are also attributes of the Lightcurve class. We knew that the Lightcurve class does not have parameters like frac_exp (fractional exposer in each bin),bg_counts (background counts in each bin) and bg_ratio (background ratio in each bin) which are optional parameters of bexvar(). So to add bexvar() a method to theLightcurve class, we also included these parameters in theLightcurve class and declared them as its attributes. I started the work with this &lt;a href="https://github.com/StingraySoftware/stingray/pull/669"&gt;PR&lt;/a&gt;. However, just adding these parameters was not enough. The Lightcurve class provides some important filtering and sorting methods for Lightcurve objects. These methods did not support these optional parameters as they weren't there initially. It wouldn’t be so great if users create a Lightcurve object with all these parameters, then they may want to truncate the lightcurve or sort it or apply GTIs (Good time intervals) before calling bexvar() and the returned Lightcurve does not have these attributes. We worked on providing support for these new parameters in some of these methods.&lt;/p&gt;
&lt;p&gt;In addition to that, the bexvar() method works on the light curves with uneven sampling. Which led us to also investigate if Stingray supports the creation of such lightcurve objects. We found that the support was not very great for such data. While there was no restriction for creating a Lightcurve class with the time resolution parameter dt being an array, many methods of the Lightcurve class did not extend support for such data. We started working on providing this support after that. This led to some serious bug fixing and restless nights but finally, we were able to reach at a point where all of the existing tests are passing.&lt;/p&gt;
&lt;p&gt;Apart from this, I also created a jupiter notebook for a tutorial on the bexvar()method (see this &lt;a href="https://github.com/StingraySoftware/notebooks/pull/58"&gt;PR&lt;/a&gt;). This contains examples showcasing how to use the implemented method and also a section on the theoretical explanation of bexvar. This notebook will also be upgraded with examples of how to call bexvar() method implemented in the Lightcurve class once that work is completed.&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/680/1*YFXjL3Wc5EqBE9vaXPHNBQ.jpeg"&gt;&lt;/figure&gt;&lt;p&gt;With this final blog, my journey through &lt;a href="https://summerofcode.withgoogle.com/"&gt;GSoC”22&lt;/a&gt; comes to a happy end. You can check out my final report for this project containing rigorous details at this &lt;a href="https://mihirtripathi97.github.io/GSoC-22/"&gt;webpage&lt;/a&gt;. I will continue working with Stingray, I will continue contributing to OpenAstrnomy and other open source projects as well. I must say that GSoC has been really great it provided me the best opportunity for the beginning of my journey in the open source community. I would like to thank the &lt;a href="https://openastronomy.org/"&gt;OpenAstronomy&lt;/a&gt; organization for giving me this wonderful opportunity to contribute to open source projects for the Astrophysics community. This means a lot to me as I am one of the users of several projects of the member organizations.&lt;/p&gt;
&lt;p&gt;I would like to thank both my mentors &lt;a href="https://github.com/matteobachetti"&gt;Matteo Bachetti&lt;/a&gt; and &lt;a href="https://github.com/dhuppenkothen"&gt;Daniela Huppenkothen&lt;/a&gt; for being extremely generous, supportive, and motivating mentors. I am truly grateful to have you both as my mentors.&lt;/p&gt;
&lt;img alt="" height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=1279d3b337e7" width="1"&gt;</description><category>stingray</category><guid>http://openastronomy.org/Universe_OA/posts/2022/09/20220912_1708_mihirtripathi97/</guid><pubDate>Mon, 12 Sep 2022 16:08:26 GMT</pubDate></item><item><title>GSoC Blog#4 (Final Submission)</title><link>http://openastronomy.org/Universe_OA/posts/2022/09/20220912_1225_aman-pandey-afk/</link><dc:creator>AMAN PANDEY</dc:creator><description>&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/680/1*dfjiDfMcY8h9eEOySAnxbA.jpeg"&gt;&lt;/figure&gt;&lt;p&gt;It’s the end of GSoC 2022; man, it was a great experience! Starting with aimless contributions brought me to a project which united my two passions: programming and astrophysics. The three-month journey and the community bonding period were excellent learning experiences.&lt;/p&gt;
&lt;p&gt;From learning a new and robust language like Julia to using Unit Testing for real-world data, I learned a lot about programming. This period also tested my git skills (as open source is one of the best ways to get your hands dirty in it) as I resolved merge conflicts, changed branch heads whenever required, and always kept an eye on the log history. My whole project is presented here in terms of git commits and some explanation of what these are doing. In the end, I will point out what’s next from here, and I hope Stingray will grow up to become a beloved package like many others in the Julia Community.&lt;/p&gt;
&lt;p&gt;I did the project in 5PRs (three merged and two open to review), which are listed below:&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;&lt;a href="https://github.com/StingraySoftware/Stingray.jl/pull/1"&gt;&lt;em&gt;Implement Workflow&lt;/em&gt;&lt;/a&gt;&lt;em&gt; (Merged)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/StingraySoftware/Stingray.jl/pull/2"&gt;&lt;em&gt;Add Fourier methods and tests&lt;/em&gt;&lt;/a&gt;&lt;em&gt; (Merged)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/StingraySoftware/Stingray.jl/pull/3"&gt;&lt;em&gt;Implement GTI Reading and Handling&lt;/em&gt;&lt;/a&gt;&lt;em&gt; (Merged)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/StingraySoftware/Stingray.jl/pull/7"&gt;&lt;em&gt;Implement EventList&lt;/em&gt;&lt;/a&gt;&lt;em&gt; (Open)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/StingraySoftware/Stingray.jl/pull/9"&gt;&lt;em&gt;Documentation&lt;/em&gt;&lt;/a&gt;&lt;em&gt; (Open)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;I also documented this journey in four other blogs: &lt;a href="https://medium.com/@aman_p/gsoc-blog-0-8f65bf844cd8"&gt;Blog0&lt;/a&gt;, &lt;a href="https://medium.com/@aman_p/gsoc-blog-1-cc0c0995d56e"&gt;Blog1&lt;/a&gt;, &lt;a href="https://medium.com/@aman_p/gsoc-blog-2-63d283e1a60b"&gt;Blog2&lt;/a&gt;, &lt;a href="https://medium.com/@aman_p/gsoc-blog-3-350c7b7dad61"&gt;and Blog3&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Further Explanation:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Starting a package from scratch can look like a behemoth task; you can confuse which methods to begin with, what the architecture will be, and how I will ensure continuous testing. Fortunately, my mentors were very helpful, and in the community bonding period itself, I initialized a basic package with the help of PkgTemplate.jl with integrated CIs.&lt;/p&gt;
&lt;p&gt;My mentor &lt;a href="https://github.com/matteobachetti"&gt;&lt;strong&gt;Matteo&lt;/strong&gt;&lt;/a&gt; suggested I go on to implement Fourier methods first as they are the primary thing required to create power and cross-spectra from an array. I started on with it, and the PR was a great lesson both in terms of how much code I needed to port with passing tests and how idiomatic I had to keep it to discover the full power of Julia. My initial code was pretty pythonic, and my other mentor, &lt;a href="https://github.com/giordano"&gt;&lt;strong&gt;Mosè&lt;/strong&gt;&lt;/a&gt;, gave much good advice on how to fix them and keep the code readable. Still, due to the sheer amount of code and tests I needed to write, the code is currently non-idiomatic for a few functions, and I hope to make them efficient in the future.&lt;/p&gt;
&lt;p&gt;After this, I needed a working tool to handle GTIs; trust me; this was the best part of the project. I was having fun with different interval operations I needed to implement, looking at them from different angles and maintaining the code’s sanctity. The tests passed, and I had pretty idiomatic code written there with handling file reading (HDF5 and FITS) for some tests, which helped me in the future.&lt;/p&gt;
&lt;p&gt;After the mid-evals, I got somewhat busy due to tests and college courses. After the first week, I started contributing again by considering different ways to represent photon arrival and count data. Using structs and methods for them (including extending Base functions when required) was the way to go, and after half of the second phase, I managed to get a PR on these things though the code is still in review. One can now plot the LightCurves, read data from a FITS file and use the Fourier methods to get the power and cross-spectra and perform operations on the related GTIs. But how?&lt;/p&gt;
&lt;p&gt;In the final week, my focus was to provide documentation on the functions mentioned, taking help from the Python package and changing it as required, especially as the markdowns are different for both languages’ docstrings. I followed it with writing a user guide, although it is still incomplete in the current PR, and I hope to get it done well by the end of this month (working outside of GSoC :).&lt;/p&gt;
&lt;p&gt;As a whole, this project was exciting to me. I can safely say that I lacked experience in many parts, but my mentors were fantastic, and I had some great discussions with them. The essential power of Julia is how it handles memory and compiles the code as required (JIT), and with this in focus, the project can still grow to various extents.&lt;/p&gt;
&lt;p&gt;For example, good use of type systems in the Fourier methods, a clearer way to use generators (the resumable functions), and user APIs for Cross and Power Spectra would be the first thing this package needs working on. After this, we can implement other features like Bi-Spectra and Var-Energy Spectra. In the end, one can see how powerful Julia can be if programmed correctly. Below is the runtime for reading the same files in Python and Julia (Julia is doing almost 40 times faster). This order of speed boost is still an excellent achievement for Julia while keeping all the important arrays and metadata from the file in a struct.&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/925/1*p-F3ErLlJtjTA4fSQSqeJw.png"&gt;&lt;figcaption&gt;Python Code&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/633/1*hyOqX2j2UxQ59IxKwxej4w.png"&gt;&lt;figcaption&gt;Julia Code&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;With this, I end this blog and this awesome GSoC program, with a hope to keep contributing to this and other open source projects and learning new things. Great thanks to my mentors, Open Astronomy and Google for providing this opportunity.&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/736/0*eGlGa84zNsGaMHL0.jpg"&gt;&lt;figcaption&gt;Source: Pinterest&lt;/figcaption&gt;&lt;/figure&gt;&lt;img alt="" height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=1c27a20f13a2" width="1"&gt;</description><category>stingray</category><guid>http://openastronomy.org/Universe_OA/posts/2022/09/20220912_1225_aman-pandey-afk/</guid><pubDate>Mon, 12 Sep 2022 11:25:22 GMT</pubDate></item><item><title>GSoC @ Stingray: Testing Testing Testing …</title><link>http://openastronomy.org/Universe_OA/posts/2022/08/20220826_1631_mihirtripathi97/</link><dc:creator>Mihirtripathi</dc:creator><description>&lt;h4&gt;GSoC @ Stingray: Testing Testing Testing …&lt;/h4&gt;&lt;p&gt;After getting the code for bexvar in working condition, the next task in front of me was to test the code. As I mentioned in the last blog I was completely new to software testing. This meant a lot of new things to learn.&lt;/p&gt;
&lt;p&gt;In this blog, I am going to write about my experience with testing. This was one of the best learning experiences of my GSoC journey so far. With the help of my mentors, I arrived at the conclusion that primarily there are three kinds of tests that would be needed for bexvar.&lt;/p&gt;
&lt;p&gt;(1) Unit tests to check if various components of my code provide the correct outputs individually.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;(2) Some functional tests to check if the entire bexvar() function works properly and gives the desired output.&lt;/p&gt;
&lt;p&gt;(3) Some other tests to check if proper warnings and errors are raised in the case of bad inputs.&lt;/p&gt;
&lt;p&gt;I started with the unit tests. Creating the unit tests for internal functions was comparatively easy. Two of the three internal functions provided deterministic outputs. All that was needed for testing them was to calculate the desired output and compare it with the output from the code.&lt;/p&gt;
&lt;p&gt;One of the major problems arose while designing functional tests. The bexvar() function returns an array that contains the samples of the log of the bexvar (i.e. log(\sigma_{count rate})). These samples are proportional to the posterior distribution of log(\sigma_\{count rate}). These samples are generated by an MCMC generator and therefore the elements and the number of elements of the output array are different after each run for the same data. This makes testing the result more difficult as the elements of the array could not be compared with a predetermined result.&lt;/p&gt;
&lt;p&gt;As the bexvar() aims to provide the posterior distribution of log(Sigma_\{count rate}) the elements as individuals do not matter but the shape of their histogram provides the posterior distribution. Therefore we decided to test the results with some statistical parameters derived from the generated samples which quantify the distribution.&lt;/p&gt;
&lt;p&gt;The problems that I faced while designing the third type of test, helped me find and resolve multiple unseen issues with the code. It took me more time than I expected to complete the testing phase. However, I am glad to announce that the all tests are now passing successfully. Additionally, I also passed the mid-term evaluations! Phew!&lt;/p&gt;
&lt;p&gt;At end of the testing phase, The &lt;a href="https://github.com/StingraySoftware/stingray/pull/664"&gt;PR&lt;/a&gt; was ready to be merged, after a few minor updates in the docstrings it was merged! Yaay! The work is not yet done though. Next, I am working to add a method to Stingray’s lightcurve class. In addition to this, I will be creating a tutorial page for using the bexvar and will also make some more improvements in the code if time permits.&lt;/p&gt;
&lt;img alt="" height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=9d1572ac43ef" width="1"&gt;</description><category>stingray</category><guid>http://openastronomy.org/Universe_OA/posts/2022/08/20220826_1631_mihirtripathi97/</guid><pubDate>Fri, 26 Aug 2022 15:31:33 GMT</pubDate></item><item><title>GSoC Blog #3</title><link>http://openastronomy.org/Universe_OA/posts/2022/08/20220820_0702_aman-pandey-afk/</link><dc:creator>AMAN PANDEY</dc:creator><description>&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/680/1*dfjiDfMcY8h9eEOySAnxbA.jpeg"&gt;&lt;/figure&gt;&lt;p&gt;Mid Evaluations are over, and I’m glad to be back at work. As the base functionality is done now, I am on to provide user APIs to create cross spectra and periodograms from actual astronomical data easily.&lt;/p&gt;
&lt;p&gt;I was busy the first week after the mid-term due to intern season at my campus, so that I couldn’t contribute much. Afterward, I started by understanding different functionalities related to photon count events next week. The plan was to:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Read the photon count data from different file formats and get the essential information like time, GTIs, PI channels, etc.&lt;/li&gt;&lt;li&gt;Create EventList struct and handle different methods like sorting, joining, filtering, and simulating these data.&lt;/li&gt;&lt;li&gt;Test these methods by appropriately re-binning, creating periodograms, and plotting the data.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;There was also modification in the git workflow as the documentation branch was based on the gti one, which now has its parent main.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;For the 3rd week, I have worked on the EventList APIs and the data reading part. Its currently implemented for the FITS extension, but I will expand to other formats like HDF5 or ECSV. I have also studied LightCurve structure and implemented a to and from conversion with EventLists, although its methods are needed to be worked upon.&lt;/p&gt;
&lt;p&gt;In the coming weeks, I aim to create extensive tests, debug these methods, and optimize them in Julia. After these are done, other features like coherence and time lags will also be necessary. The period will &lt;em&gt;end&lt;/em&gt; with documentation and refactoring of already existing codes, and &lt;em&gt;if&lt;/em&gt; I get time, I will work on variability vs. energy spectrum.&lt;/p&gt;
&lt;img alt="" height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=350c7b7dad61" width="1"&gt;</description><category>stingray</category><guid>http://openastronomy.org/Universe_OA/posts/2022/08/20220820_0702_aman-pandey-afk/</guid><pubDate>Sat, 20 Aug 2022 06:02:40 GMT</pubDate></item><item><title>GSoC Blog#2</title><link>http://openastronomy.org/Universe_OA/posts/2022/07/20220726_0559_aman-pandey-afk/</link><dc:creator>AMAN PANDEY</dc:creator><description>&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/680/1*dfjiDfMcY8h9eEOySAnxbA.jpeg"&gt;&lt;/figure&gt;&lt;p&gt;The first half of the coding period is almost done, and here I am with the updates! As stated at the end of the last blog, I started the 3rd week by improving the &lt;a href="https://github.com/StingraySoftware/Stingray.jl/pull/2"&gt;second PR&lt;/a&gt;. I performed pretty intensive memory and performance analysis on the functions in fourier.jl, using BenchmarkTools and .mem files to analyze bottlenecks in the program. With my mentors’ help, I removed many allocation and type-stability related issues during that time. I also had some problems with non-idiomatic code, like I could use multiple-dispatch or dot broadcast in functions, some of which I solved, and some are due for refactoring after the mid-evaluation. After finishing the improvements and getting my second PR merged, I planned to work on LightCurves and implement periodograms and other APIs so that users can easily manipulate photon count data. But my mentor suggested I implement file reading and mechanisms to manage the GTIs (Good Time Intervals) obtained from these files.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Working out the GTI mechanisms&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I had learned a lot from the previous PR, and one of the things was I should try to implement some of the methods in my way rather than using the python algorithms with an idiomatic Julian code in mind. I started the 4th week with methods for reading GTIs from a FITS file (For those unfamiliar, it is a file format for storing, processing, and transmitting scientific data, especially images). I used the FITSIO.jl package, and experimenting on the terminal led me to manipulate HDUs and their data. One thing I thoroughly thought of was the appropriate data structure of the GTIs. Should I use Intervals from the Intervals.jl package? Or a vector of vector like the python library does? I finally decided to use what I was using in the fourier.jl, an AbstractMatrix of Reals. It was easy to access data from them, and you could use slices to get a list of start and end times. For the operations, I had to convert among matrix, intervals frequently, and vectors as the Intervals.jl provided many ways to manipulate GTIs like union or intersection or getting its complement, i.e., Bad Time Intervals. With some more methods like creating masks and GTIs from conditions and implementing Tests for all of these functions, I was finished with the gti.jl file. A little performance analysis told me that the code was efficient. After some refactoring, like removing code duplication by merging union and intersection in the same function, I was done with the PR. It has some minor changes currently to be made before it gets merged.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;&lt;strong&gt;Working on the documentation&lt;/strong&gt;&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*lbM1DS0_-Ja0lb53Owb6PQ.png"&gt;&lt;/figure&gt;&lt;p&gt;As the mid evaluations have begun this week, I will be taking some time to write the docstring and deploy them on GitHub. The stingray python docs are pretty good, so I will mostly use them as a Base and tweak them as necessary (when there is a different function signature or the Julian way of doing things is different). Documenter.jl will be the package I would be using for this. The complete documentation will be a milestone for the end of the program, where I, along with my mentors, will try to write notebook tutorials for the package and host them.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;For the second phase&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I hope to qualify for the mid-evals, after which the second phase will begin. The core implementation is done; users can now use the library and its different methods to read from a file, process the data, and create periodograms. The main motive now will be to ease its access and implement other helpful features, a major one of which will be plotting the periodograms. I initially proposed working with these APIs before mid-evals, but who knows about the future? I have done some things meant for the other half, so I guess it’s okay. As an end note, I am pretty much excited for the other half of this program, it has made me learn a lot, and the workings of Julia awe-inspire me as I explore it side by side. Goodbye for now!&lt;/p&gt;
&lt;img alt="" height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=63d283e1a60b" width="1"&gt;</description><category>stingray</category><guid>http://openastronomy.org/Universe_OA/posts/2022/07/20220726_0559_aman-pandey-afk/</guid><pubDate>Tue, 26 Jul 2022 04:59:13 GMT</pubDate></item><item><title>GSoC @ Stingray: Diving into coding period. blog #2</title><link>http://openastronomy.org/Universe_OA/posts/2022/07/20220724_1811_mihirtripathi97/</link><dc:creator>Mihirtripathi</dc:creator><description>&lt;p&gt;Hey there!&lt;/p&gt;
&lt;p&gt;It is time to write a blog about my experience in the coding period so far. So here it goes.&lt;/p&gt;
&lt;p&gt;The official coding period for GSoC’22 started on the 13th of June. After discussing with mentors I decided that the first task would be to create a base structure of the code for Bexvar. As the method was already implemented by Dr. Johannes Buchner (who also suggested implementing this method in Stingray)and David Bogensberger, we decided to use this &lt;a href="https://github.com/JohannesBuchner/bexvar"&gt;implementation&lt;/a&gt; as a reference.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;I spent the first 2–3 days planning the structure of the code and planning its implementation in Stingray’s code base. At first, the implementation seemed easy. Although as I explored more and discussed my ideas with my mentors I realized that there are many small but important changes that need to be made.&lt;/p&gt;
&lt;p&gt;In addition to these, I realized that I had to set up a proper environment on my computer to write, edit and test the codes that I write. I decided to use &lt;a href="https://code.visualstudio.com/"&gt;Visual Studio Code&lt;/a&gt; (VS Code) for it. Before the contribution period, I had only a little familiarity with Github and had never used git in my local system. I somehow made it through the contribution period without installing it. Now since I had an open source project at hand which will require frequent commits, I decided to install git and GitHub desktop on my computer and learn to use git with CLI. I found out that along with many useful tools for professional programming, VS Code also provided support to use git inside from the editor, this seemed quite useful for my purpose. I learned how to install and work with multiple versions of Python. I learned how to set up a Python virtual environment and use it to test codes in a controlled environment. I had to go through multiple iterations of installing, uninstalling, and then reinstalling several packages to set everything perfectly. This made me a bit irritated but later on, I realized that this helped me save a lot of time while coding for the project.&lt;/p&gt;
&lt;p&gt;After going through a few iterations the base code was ready and working. It still needed some improvements and structural changes. It had a core function that reads the light curve data from an AstroPy table. After that, it would call internal functions successively to finally obtain the Bayesian Excess Variance of count rate. My mentor Prof. Matteo suggested that I start a PR with this version of the code. As I made this &lt;a href="https://github.com/StingraySoftware/stingray/pull/664"&gt;PR&lt;/a&gt;, we started discussing how to improve the code.&lt;/p&gt;
&lt;p&gt;My mentors pointed out that my core function &lt;em&gt;bexvar()&lt;/em&gt; needed further modularization. We decided to separate it into two functions, A core function &lt;em&gt;bexvar()&lt;/em&gt; which will accept light curve data as a set of NumPy arrays or lists and calculate bexvar, and a &lt;em&gt;bexvar_from_table()&lt;/em&gt; function which can read light curve data from an AstroPy table and call &lt;em&gt;bexvar()&lt;/em&gt;. This change made the core &lt;em&gt;bexvar()&lt;/em&gt; function more general as now users would not need to have light curve data in form of an AstroPy Table object to obtain bexvar. Also, in the future, we can create a function like &lt;em&gt;bexvar_from_table()&lt;/em&gt; which can read data from Stingray’s Lightcurve object and call &lt;em&gt;bexvar()&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In the next phase, I updated existing docstrings, added docstrings where it was missing, and worked on code formating. At this stage, the code was still failing in Stingray’s CI tests. The reason behind the failures was that the code uses an integrator &lt;a href="https://johannesbuchner.github.io/UltraNest/_modules/ultranest/integrator.html#ReactiveNestedSampler"&gt;&lt;strong&gt;ReactiveNestedSampler&lt;/strong&gt;&lt;/a&gt; from &lt;a href="https://arxiv.org/abs/2101.09604"&gt;UltraNest — a robust, general purpose Bayesian inference engine&lt;/a&gt;. UltraNest is not a required dependency for Stingray, hence CI tests were failing with import error. To resolve this, the import statement of UltraNest in bexvar.py needed to be moved inside a try-except statement. This would restrict the user from using bexvar.py if UltraNest is not installed. With this change, the code has passed the majority of CI tests.&lt;/p&gt;
&lt;p&gt;The overall experience of the coding period so far has been good. During this period I learned a lot about the essentials of open-source programming. I am learning to think like a programmer. I learned how small improvements in code make it more general and versatile. I learned about the best practices to write code. I must say that all this time my mentors Matteo and Daniela have been quite supportive and helpful. They have patiently listened to my queries and doubts and have always helped me with them.&lt;/p&gt;
&lt;p&gt;My code is running perfectly now, from this week onwards I will be focussing on writing tests for the code. Writing tests for a code is a completely new experience for me. I am looking forward to learn a lot about professional code testing in the following weeks. I will soon be back with a blog on my experience with testing. Till then take care! Goodbye!&lt;/p&gt;
&lt;img alt="" height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=f24a03c00014" width="1"&gt;</description><category>stingray</category><guid>http://openastronomy.org/Universe_OA/posts/2022/07/20220724_1811_mihirtripathi97/</guid><pubDate>Sun, 24 Jul 2022 17:11:57 GMT</pubDate></item></channel></rss>