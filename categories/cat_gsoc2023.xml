<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Universe OpenAstronomy (Posts about gsoc2023)</title><link>http://openastronomy.org/Universe_OA/</link><description></description><atom:link href="http://openastronomy.org/Universe_OA/categories/cat_gsoc2023.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Wed, 12 Jul 2023 01:18:11 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Improving time efficiency of Vaex Implementation</title><link>http://openastronomy.org/Universe_OA/posts/2023/07/20230706_0000_1someshverma/</link><dc:creator>Somesh Verma</dc:creator><description>&lt;p&gt;Though Vaex reduced memory use by RADIS to compute specturm but it is slow for smaller databank and in our case when the number of lines in the databank is very less . The slow performance of Vaex for smaller dataframes is due to three main reasons for our implementation of RADIS&lt;/p&gt;

&lt;ul&gt;
&lt;!-- TEASER_END --&gt;
&lt;li&gt;First vaex is optimized for larger databank and doesn’t focus that much for smaller dataframe .&lt;/li&gt;
&lt;li&gt;Vaex uses virtual columns to reduce memory and only compute the virutal column when it is required it saves memory space but in case when virtual column
is required multiple times then it is computed multiple times and it costs time . For Pandas it only compute the column only once and saves it for further calculations and in-memory compute of Pandas are faster than Vaex for smaller dataframes.&lt;/li&gt;
&lt;li&gt;Vaex is based on Apache Arrow and uses Expression class for column while for Pandas which stores column as numpy no conversion is required to use library functions of numpy but for vaex some operations require explict conversion to numpy array and it costs time.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Apart from this there was issue it the implementation of vaex which are now optimized by better alternatives.
Intially the time graph for Vaex and Pandas in terms of time comparison was as given below-&lt;/p&gt;

&lt;p&gt;Total Time  which is the sum of loading time and computation time for calculating spectrum .
Plot of Total Time vs Number of lines Graph&lt;/p&gt;

&lt;p&gt;&lt;img alt="Vaex Comparison" src="https://1someshverma.github.io/images/earlierTotal.png"&gt;&lt;/p&gt;

&lt;p&gt;Computation time , it is time required to compute the spectrum using Vaex or Implementation
Plot of Compuation Time vs Number of lines Graph&lt;/p&gt;

&lt;p&gt;&lt;img alt="Vaex Comparison" src="https://1someshverma.github.io/images/earlierCom.png"&gt;&lt;/p&gt;

&lt;p&gt;##Optimizations&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Calculating Sum&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;At first we were computing the sum as&lt;/p&gt;

&lt;div class="language-plaintext highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt; error = df[b].S.sum() / df.S.sum() * 100
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;but later changed it to&lt;/p&gt;
&lt;div class="language-plaintext highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;error_cutoff = df[b].sum(df[b].S) / df.sum(df.S) * 100
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The time taken to calculate 25 spectra decreased from 6.0 s to 5.4 s&lt;/p&gt;

&lt;p&gt;Code used was&lt;/p&gt;

&lt;div class="language-plaintext highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;from radis import calc_spectrum
import time

t0 = time.time()
for i in range(25):
s = calc_spectrum(2000, 2010,         # cm-1
molecule='CO',
isotope='1,2,3',
pressure=1.01325,   # bar
Tgas=1000,
mole_fraction=0.1,
databank='hitemp',  # or 'hitemp'
diluent = "air",
verbose = 0,
engine = "vaex"
)
t1 = time.time()
print(t1 -t0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;Not using df.extract()
After masking some of the rows, that is filtering some of the rows based on some conditions . Then I was using df.extract(), later i found it was using a lot of time .So i commented that and refactored code to work without it .
&lt;div class="language-plaintext highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;df = df.extract() # later commented it .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Improvements after this was quite impressive as i found out running below codes&lt;/p&gt;

&lt;p&gt;It reduced calculation time for the code below by 10 seconds&lt;/p&gt;

&lt;div class="language-plaintext highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;from radis import calc_spectrum

import time
t0=time.time()

s = calc_spectrum(1500, 2500,         # cm-1
molecule='H2O',
isotope='1,2,3',
pressure=1.01325,   # bar
Tgas=700,           # K
mole_fraction=0.1,
wstep='auto',
path_length=1,      # cm
databank='hitemp',  # or 'hitemp', 'geisa', 'exomol'
engine='vaex',
)

s.apply_slit(0.5, 'nm')       # simulate an experimental slit

t1=time.time()

print('Time taken : '+str(t1 - t0))

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And reduced 0.5 seconds calculation time for the code&lt;/p&gt;

&lt;div class="language-plaintext highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;from radis import calc_spectrum
import time
t0=time.time()
s = calc_spectrum(2000, 2010,         # cm-1
molecule='CO',
isotope='1,2,3',
pressure=1.01325,   # bar
Tgas=1000,
mole_fraction=0.1,
databank='hitran',  # or 'hitemp'
diluent = "air",
verbose = 3,
engine = "vaex"
)
t1=time.time()


print('Time taken : '+str(t1-t0))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;After all of this updated time graph were as below
&lt;img alt="Vaex Comparison" src="https://1someshverma.github.io/images/updatedCom.png"&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt="Vaex Comparison" src="https://1someshverma.github.io/images/updatedTotal.png"&gt;&lt;/p&gt;

&lt;p&gt;I significant improvement can be observed from it .&lt;/p&gt;

&lt;p&gt;Now to smaller time performance of smaller dataframe , I converted the vaex dataframes to pandas for smaller databases. And overall improvemets are as&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Memory performance is improved for all dataframes.&lt;/li&gt;
&lt;li&gt;Time performance is same for smaller dataframes , and for larger dataframes time performance of vaex is quite better than Pandas.&lt;/li&gt;
&lt;/ul&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2023/07/20230706_0000_1someshverma/</guid><pubDate>Wed, 05 Jul 2023 23:00:00 GMT</pubDate></item><item><title>GSoC Week 4 Update</title><link>http://openastronomy.org/Universe_OA/posts/2023/07/20230703_1917_pupperemeritus/</link><dc:creator>pupper emeritus</dc:creator><description>&lt;h2&gt;


&lt;!-- TEASER_END --&gt;
Brief
&lt;/h2&gt;

&lt;p&gt;This week I successfully finished implementing the fast algorithm. Now my &lt;code&gt;LombScargleCrossspectrum&lt;/code&gt; and &lt;code&gt;LombScarglePowerspectrum&lt;/code&gt; are that much closer to completion. Only things left to sort out/implement are time lags and phase lag functions and checking the phase of the output.&lt;/p&gt;

&lt;h2&gt;


Details
&lt;/h2&gt;

&lt;p&gt;Testing on the following synthetic data has been conducted to compare the outputs with the existing cross spectrum and power spectrum for evenly spaced data first then checking the outputs of the lomb scargle variants on unevenly sampled data&lt;br&gt;
&lt;/p&gt;

&lt;div class="highlight js-code-highlight"&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;rand = np.random.default_rng(42)
n = 1000
t = np.linspace(0, 10, n)
y = np.sin(2 * np.pi * 3.0 * t) + 0.1 * rand.standard_normal(n)
y2 = np.sin(2 * np.pi * 3.0 * t) + 0.1 * rand.standard_normal(n)
y -= np.min(y)
y2 -= np.min(y2)
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;h3&gt;


The Cross spectra for evenly sampled data
&lt;/h3&gt;

&lt;p&gt;&lt;a class="article-body-image-wrapper" href="https://res.cloudinary.com/practicaldev/image/fetch/s--HDSGExDP--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ldcxxcpq760ym5yph7jv.png"&gt;&lt;img alt="Image description" height="417" src="https://res.cloudinary.com/practicaldev/image/fetch/s--HDSGExDP--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ldcxxcpq760ym5yph7jv.png" width="558"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;


The time lags for evenly sampled data
&lt;/h3&gt;

&lt;p&gt;As it is evident the time lags need work.&lt;/p&gt;

&lt;p&gt;&lt;a class="article-body-image-wrapper" href="https://res.cloudinary.com/practicaldev/image/fetch/s--5_uNnIpc--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/sknrib3nkos5tcnojlng.png"&gt;&lt;img alt="Image description" height="413" src="https://res.cloudinary.com/practicaldev/image/fetch/s--5_uNnIpc--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/sknrib3nkos5tcnojlng.png" width="559"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;


The power spectra for evenly sampled data
&lt;/h3&gt;

&lt;p&gt;One quirk is that the power spectrum class is returning the power spectrum with a negative sign. This is a known bug. The values otherwise are within margin of error.&lt;/p&gt;

&lt;p&gt;&lt;a class="article-body-image-wrapper" href="https://res.cloudinary.com/practicaldev/image/fetch/s--njHhZDEY--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/vtf835ktnxo9dn83iy55.png"&gt;&lt;img alt="Image description" height="417" src="https://res.cloudinary.com/practicaldev/image/fetch/s--njHhZDEY--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/vtf835ktnxo9dn83iy55.png" width="559"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;


The Lomb Scargle cross spectrum and power spectrum when data is unevenly sampled
&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;t = np.sort(rand.random(n))*10&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;


The cross spectrum
&lt;/h4&gt;

&lt;p&gt;&lt;a class="article-body-image-wrapper" href="https://res.cloudinary.com/practicaldev/image/fetch/s--LeUsZL3d--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/bzddaq7u9naiskry0x7i.png"&gt;&lt;img alt="Image description" height="417" src="https://res.cloudinary.com/practicaldev/image/fetch/s--LeUsZL3d--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/bzddaq7u9naiskry0x7i.png" width="558"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;


The power spectrum
&lt;/h4&gt;

&lt;p&gt;&lt;a class="article-body-image-wrapper" href="https://res.cloudinary.com/practicaldev/image/fetch/s--mFs4vcWd--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/yfz6sav17mw51yas49he.png"&gt;&lt;img alt="Image description" height="417" src="https://res.cloudinary.com/practicaldev/image/fetch/s--mFs4vcWd--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/yfz6sav17mw51yas49he.png" width="559"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;


The time lags
&lt;/h4&gt;

&lt;p&gt;&lt;a class="article-body-image-wrapper" href="https://res.cloudinary.com/practicaldev/image/fetch/s--bAp6Nw-1--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/qkyr5to5lbkxm2s2xbi9.png"&gt;&lt;img alt="Image description" height="413" src="https://res.cloudinary.com/practicaldev/image/fetch/s--bAp6Nw-1--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/qkyr5to5lbkxm2s2xbi9.png" width="559"&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;They are off here too. Which will be fixed in the coming week.&lt;/p&gt;

&lt;p&gt;For exhaustive testing code refer&lt;br&gt;
&lt;/p&gt;
&lt;div class="ltag_gist-liquid-tag"&gt;

&lt;/div&gt;</description><category>stingray</category><guid>http://openastronomy.org/Universe_OA/posts/2023/07/20230703_1917_pupperemeritus/</guid><pubDate>Mon, 03 Jul 2023 18:17:26 GMT</pubDate></item><item><title>Setting Up for the Kurucz PR and transitioning to the TheoReTS</title><link>http://openastronomy.org/Universe_OA/posts/2023/07/20230702_1407_menasrac/</link><dc:creator>Racim MENASRIA</dc:creator><description>&lt;p&gt;This week was not the most enjoyable phase of the project so far, as I had to exert considerable effort to fix failing tests before opening a pull request.&lt;/p&gt;
&lt;p&gt;Once I ensured that the initial tests passed, I wrote my own tests to confirm that the new AdB Kurucz class didn’t interfere with any part of the existing code. At this point, I encountered a primary issue. I hadn’t noticed that one of the methods I had adapted from ExoJAX was still reading a file which necessitated an ExoJAX package dependency. This caused the build to fail on GitHub due to one of the tests in my kurucz_test.py file failing.&lt;/p&gt;
&lt;p&gt;Since there’s a conflict related to the JAX installation on Windows, I couldn’t add it to the requirements file. Doing so would create a conflict for every Windows user installing Radis. Consequently, I had to write a program to extract the data from this package and store a copy of it in a local file called pfdat.txt. This enabled the problematic function to read from the local copy instead of the ExoJAX file. This solution successfully rectified the problem, and now my PR passes the tests and is awaiting review before merging.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;The next step is to transition to the TheoReTS as planned. According to the TheoReTS website, it is an information system for theoretical spectra based on variational predictions from molecular potential energy and dipole moment surfaces. It is jointly developed by the PMT team of GSMA (Reims), Tomsk University, and IAO Acad Sci. Russia. As a result, it provides two access points, one French and the other Russian. However, I noticed that the access to the French website (&lt;a href="http://theorets.univ-reims.fr/"&gt;http://theorets.univ-reims.fr/&lt;/a&gt;) is currently unavailable, preventing me from visualizing the data. This is an issue I should discuss with my mentors.&lt;/p&gt;
&lt;img alt="" height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=d9643c0269aa" width="1"&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2023/07/20230702_1407_menasrac/</guid><pubDate>Sun, 02 Jul 2023 13:07:42 GMT</pubDate></item><item><title>Scraper Things</title><link>http://openastronomy.org/Universe_OA/posts/2023/06/20230630_0133_exitflynn/</link><dc:creator>exitflynn</dc:creator><description>&lt;p&gt;Most of the week was spent rewriting the Scraper functions to go with the new parse-pattern and then looking for edge cases in the new implementations, fixing bugs and updating tests.&lt;/p&gt;
&lt;h2 id="catching-up"&gt;{{Catching up}}
&lt;span&gt;
&lt;!-- TEASER_END --&gt;
&lt;a href="https://exitflynn.github.io/blog/tags/gsoc/index.xml#catching-up"&gt;
&lt;svg height="100%" viewbox="0 0 28 23" width="19" xmlns="http://www.w3.org/2000/svg"&gt;&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"&gt;&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"&gt;&lt;/path&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;In the scraper, while trying to merge &lt;code&gt;baseurl&lt;/code&gt; (an strftime formatted pattern i.e.&lt;code&gt; %Y%m&lt;/code&gt; etc) and &lt;code&gt;pattern&lt;/code&gt; (parse formatted pattern i.e. &lt;code&gt;{year:4d}{month:2d}&lt;/code&gt; etc), I faced two choices, we could either:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Make the input all parse-style formatted. generate the datetime-compatible string from here wherever it is required, however the problem i was running into here is parse-stuff like &lt;code&gt;{year:2d}&lt;/code&gt; will collide with &lt;code&gt;{instrument}&lt;/code&gt; like placeholders on which we mean to call &lt;code&gt;.format(**kwargs)&lt;/code&gt; on. All the ways I could think of pulling it off included adding a large no. of lines of code in the really early part of &lt;code&gt;__init__()&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Make the input all datetime formatted and generate the parse pattern from here. The problem with this is there are edge-cases when sometimes users define variables like &lt;code&gt;{Level:1d}&lt;/code&gt; which we have no way of knowing beforehand. One way to go about this could’ve been that we tell the user to define a pattern string in addition to baseurl whenever they have any new variables like that.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We ended up going with the first. My mentor, &lt;a href="https://github.com/Nabobalis"&gt;Nabil&lt;/a&gt; introduced me to how there’s a prevalence of using double-curly brackets in places where we need to escape / use them with single curly brackets, and sure enough, the &lt;code&gt;parse&lt;/code&gt; module supports that. So that took care of the problem there, I was mostly a bit concerned that I’ll have to go back to the second way even though I had started with it before pivoting to the first one.&lt;/p&gt;
&lt;h2 id="communication"&gt;Communication
&lt;span&gt;
&lt;a href="https://exitflynn.github.io/blog/tags/gsoc/index.xml#communication"&gt;
&lt;svg height="100%" viewbox="0 0 28 23" width="19" xmlns="http://www.w3.org/2000/svg"&gt;&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"&gt;&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"&gt;&lt;/path&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;Nabil pointed out that we weren’t being very good at communicating and that has a negative effect on the project which lead me to change how I was approaching it.&lt;/p&gt;
&lt;p&gt;A lot of times I was debugging things by including print statements here and there, and since my project now involves changing API it had me updating tests and a lot of these times the problem would just be in my understanding on how to convert the patterns and just how the new input should look like. Previously, I would only send a message on the matrix room when I had a question. And most of the times I’d still hold out hope for solving something by myself when I have the strength to pick it up later. But it also makes sense because there’d be no way to differentiate that from me not doing anything. Also around 75% of the time I’ve drafted out questions, I found out an answer along the way. From now on I realise instead of just asking questions, I should think of it as a logging / progress-updating activity first which sounds obvious in hindsight.&lt;/p&gt;
&lt;h2 id="to-regex-or-not-to-regex"&gt;To regex or not to regex
&lt;span&gt;
&lt;a href="https://exitflynn.github.io/blog/tags/gsoc/index.xml#to-regex-or-not-to-regex"&gt;
&lt;svg height="100%" viewbox="0 0 28 23" width="19" xmlns="http://www.w3.org/2000/svg"&gt;&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"&gt;&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"&gt;&lt;/path&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;The next part where I was stuck at was in converting a pattern that involved custom placeholders like &lt;code&gt;{{CAR_ROT:4d}}&lt;/code&gt; or &lt;code&gt;{{:3d}}&lt;/code&gt; to their regex counterparts like  &lt;code&gt;(\d){3}&lt;/code&gt;, &lt;code&gt;(\d){16}&lt;/code&gt; etc without using like a l o t of regex, any less complex method than using a conversion function etc. However, after a quick conversation with the mentors and I realised that I had been mistakenly assuming that strftime required regex patterns. Earlier I thought that regex would no longer be part of the end-user experience but still somehow exist in the codebase but this is when I realised that we can entirely do away with it.&lt;/p&gt;
&lt;h2 id="rewrite-then-remove-"&gt;Rewrite then Remove? 💀
&lt;span&gt;
&lt;a href="https://exitflynn.github.io/blog/tags/gsoc/index.xml#rewrite-then-remove-"&gt;
&lt;svg height="100%" viewbox="0 0 28 23" width="19" xmlns="http://www.w3.org/2000/svg"&gt;&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"&gt;&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"&gt;&lt;/path&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;I also realised that the &lt;code&gt;_extractDateURL()&lt;/code&gt; function was made redundant &lt;em&gt;after&lt;/em&gt; rewriting it since I found out later that it was only called at one place and that part of the code was no longer required thanks to the existence of a parse-pattern. That’s a nice message to keep in mind for the future.&lt;/p&gt;
&lt;h2 id="modern-day-cain"&gt;Modern Day Cain
&lt;span&gt;
&lt;a href="https://exitflynn.github.io/blog/tags/gsoc/index.xml#modern-day-cain"&gt;
&lt;svg height="100%" viewbox="0 0 28 23" width="19" xmlns="http://www.w3.org/2000/svg"&gt;&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"&gt;&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"&gt;&lt;/path&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;Another question I encountered was if we could assume that any {year:2d} or %y type 2-digit year xx to be interpreted to be in the 21st century like 20xx or not.&lt;/p&gt;
&lt;h2 id="issue-found"&gt;Issue found
&lt;span&gt;
&lt;a href="https://exitflynn.github.io/blog/tags/gsoc/index.xml#issue-found"&gt;
&lt;svg height="100%" viewbox="0 0 28 23" width="19" xmlns="http://www.w3.org/2000/svg"&gt;&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"&gt;&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"&gt;&lt;/path&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;I also found this bug in the codebase:
In the current &lt;code&gt;scraper._check_timerange()&lt;/code&gt;, it takes the simpler way &lt;code&gt;if&lt;/code&gt; we provide it with an extractor // parse-pattern and a more complex way if we don’t, however as it is implemented right now&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0"&gt;&lt;code class="language-python"&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #f92672;"&gt;from&lt;/span&gt; sunpy.net.scraper &lt;span style="color: #f92672;"&gt;import&lt;/span&gt; Scraper
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;&lt;span style="color: #f92672;"&gt;from&lt;/span&gt; sunpy.time &lt;span style="color: #f92672;"&gt;import&lt;/span&gt; TimeRange
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;s &lt;span style="color: #f92672;"&gt;=&lt;/span&gt; Scraper(&lt;span style="color: #e6db74;"&gt;'%Y.fits'&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;s&lt;span style="color: #f92672;"&gt;.&lt;/span&gt;_check_timerange(&lt;span style="color: #e6db74;"&gt;'2014.fits'&lt;/span&gt;, TimeRange(&lt;span style="color: #e6db74;"&gt;"2015-01-01"&lt;/span&gt;, &lt;span style="color: #e6db74;"&gt;"2015-01-02"&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;would return True and it is intended that way in the tests but if we passed it an extractor // parse pattern&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0"&gt;&lt;code class="language-python"&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;s&lt;span style="color: #f92672;"&gt;.&lt;/span&gt;extractor &lt;span style="color: #f92672;"&gt;=&lt;/span&gt; &lt;span style="color: #e6db74;"&gt;"&lt;/span&gt;&lt;span style="color: #e6db74;"&gt;{year:4d}&lt;/span&gt;&lt;span style="color: #e6db74;"&gt;.fits"&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;s&lt;span style="color: #f92672;"&gt;.&lt;/span&gt;_check_timerange(&lt;span style="color: #e6db74;"&gt;'2014.fits'&lt;/span&gt;, TimeRange(&lt;span style="color: #e6db74;"&gt;"2015-01-01"&lt;/span&gt;, &lt;span style="color: #e6db74;"&gt;"2015-01-02"&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;it’d return False.&lt;/p&gt;
&lt;h2 id="inclusivity-is-important"&gt;Inclusivity is important
&lt;span&gt;
&lt;a href="https://exitflynn.github.io/blog/tags/gsoc/index.xml#inclusivity-is-important"&gt;
&lt;svg height="100%" viewbox="0 0 28 23" width="19" xmlns="http://www.w3.org/2000/svg"&gt;&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"&gt;&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"&gt;&lt;/path&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;Failing tests required me to inqure if we want closed-intervals in the package or open, which concluded with closed. I also found other instances in the codebase where we endorse closed intervals.&lt;/p&gt;
&lt;h2 id="future-steps"&gt;Future steps
&lt;span&gt;
&lt;a href="https://exitflynn.github.io/blog/tags/gsoc/index.xml#future-steps"&gt;
&lt;svg height="100%" viewbox="0 0 28 23" width="19" xmlns="http://www.w3.org/2000/svg"&gt;&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"&gt;&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"&gt;&lt;/path&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;Cover why the rest of tests are breaking and fix em.
Ask for review once everything works.
Try to come up with a way to write parse-patterns so as the length remains less by trying to minimize repeated values.
Also fix my Hugo setup before the night -_-&lt;/p&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2023/06/20230630_0133_exitflynn/</guid><pubDate>Fri, 30 Jun 2023 00:33:30 GMT</pubDate></item><item><title>GSoC Week 2-3 Update</title><link>http://openastronomy.org/Universe_OA/posts/2023/06/20230625_1615_pupperemeritus/</link><dc:creator>pupper emeritus</dc:creator><description>&lt;h2&gt;


&lt;!-- TEASER_END --&gt;
Brief
&lt;/h2&gt;

&lt;p&gt;These weeks I refactored the &lt;code&gt;LombScargleCrossspectrum&lt;/code&gt; and &lt;code&gt;LombScarglePowerspectrum&lt;/code&gt; classes to accommodate the fast algorithm which went smoothly.&lt;br&gt;
However when it comes to the fast algorithm. I had tunnel vision and unconsciously made the &lt;code&gt;lsft_fast&lt;/code&gt; function compute the power spectrum instead of the fourier transform. Right now I am working towards isolating the algorithm to compute the fourier transform using the Press and Rybicki optimizations(&lt;a href="https://ui.adsabs.harvard.edu/abs/1989ApJ...338..277P/abstract"&gt;https://ui.adsabs.harvard.edu/abs/1989ApJ...338..277P/abstract&lt;/a&gt;).&lt;/p&gt;
&lt;h2&gt;


Challenges Faced
&lt;/h2&gt;

&lt;p&gt;Integrating the optimization to the existing slow algorithm is giving me a bit of trouble. I'm still figuring out how to add the optimizations. If this is done, I can move onto making the time lag, phase lag functions and then onto testing and documentation.&lt;/p&gt;
&lt;h2&gt;


Details
&lt;/h2&gt;

&lt;p&gt;Added the following parameters to both the classes in order to accommodate choice between the fast and slow algorithm.&lt;br&gt;
&lt;/p&gt;

&lt;div class="highlight js-code-highlight"&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;method : str
The method to be used by the Lomb-Scargle Fourier Transformation function. `fast`
and `slow` are the allowed values. Default is `fast`. fast uses the optimized Press
and Rybicki O(n*log(n))

oversampling : float, optional, default: 5
Interpolation Oversampling Factor (for the fast algorithm)
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;



&lt;p&gt;For full code refer &lt;a href="https://github.com/StingraySoftware/stingray/pull/737"&gt;https://github.com/StingraySoftware/stingray/pull/737&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Most important part of the process is the Lomb Scargle Fourier Transform.&lt;br&gt;
The wrapper class is trivial, they only wrap the fast and slow lomb scargle fourier transform functions.&lt;/p&gt;

&lt;h2&gt;


Results using the slow algorithm
&lt;/h2&gt;

&lt;h3&gt;


On synthetic data
&lt;/h3&gt;



&lt;div class="highlight js-code-highlight"&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;rand = np.random.default_rng(42)
n = 100
t = np.sort(rand.random(n)) * n
y = np.cos(2 * np.pi * 5 * t) + 0.01 * rand.standard_normal(n)
y -= np.min(y)
lc1 = Lightcurve(t, y, err_dist="poisson")
y2 = np.cos(2 * np.pi * 5.0 * (t)) + 0.01 * rand.standard_normal(n)
y2 -= np.min(y2)
lc2 = Lightcurve(t, y2, err_dist="poisson")
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;



&lt;p&gt;&lt;a class="article-body-image-wrapper" href="https://res.cloudinary.com/practicaldev/image/fetch/s--48Z7wHCy--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/xgf4z7yaxi81aoxj9dkx.png"&gt;&lt;img alt="Image description" height="827" src="https://res.cloudinary.com/practicaldev/image/fetch/s--48Z7wHCy--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/xgf4z7yaxi81aoxj9dkx.png" width="800"&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;


On real data
&lt;/h3&gt;

&lt;h4&gt;


The lightcurve
&lt;/h4&gt;

&lt;p&gt;&lt;a href="https://heasarc.gsfc.nasa.gov/FTP/nicer/data/obs/2018_03//1200120106/xti/event_cl/ni1200120106_0mpu7_cl.evt.gz"&gt;https://heasarc.gsfc.nasa.gov/FTP/nicer/data/obs/2018_03//1200120106/xti/event_cl/ni1200120106_0mpu7_cl.evt.gz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a class="article-body-image-wrapper" href="https://res.cloudinary.com/practicaldev/image/fetch/s--2qWoGIUP--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/w3dz8zsjk2ika71ytlkx.png"&gt;&lt;img alt="Image description" height="431" src="https://res.cloudinary.com/practicaldev/image/fetch/s--2qWoGIUP--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/w3dz8zsjk2ika71ytlkx.png" width="574"&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a class="article-body-image-wrapper" href="https://res.cloudinary.com/practicaldev/image/fetch/s--F7NDO8dr--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/167buf3woin2hplbo89r.png"&gt;&lt;img alt="Image description" height="417" src="https://res.cloudinary.com/practicaldev/image/fetch/s--F7NDO8dr--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/167buf3woin2hplbo89r.png" width="559"&gt;&lt;/a&gt;&lt;/p&gt;</description><category>stingray</category><guid>http://openastronomy.org/Universe_OA/posts/2023/06/20230625_1615_pupperemeritus/</guid><pubDate>Sun, 25 Jun 2023 15:15:57 GMT</pubDate></item><item><title>Into the Summer of Code</title><link>http://openastronomy.org/Universe_OA/posts/2023/06/20230624_0133_exitflynn/</link><dc:creator>exitflynn</dc:creator><description>&lt;p&gt;I had my end-semester exams during the Community Bonding Period and the real-early part of the Coding Period. However, my mentors were super-accomodating.
I spent a few days on plans with friends before bidding goodbye for the summers, travelling home and relaxing a bit.&lt;/p&gt;
&lt;h3 id="the-talk"&gt;The Talk
&lt;!-- TEASER_END --&gt;
&lt;span&gt;
&lt;a href="https://exitflynn.github.io/blog/tags/gsoc/index.xml#the-talk"&gt;
&lt;svg height="100%" viewbox="0 0 28 23" width="19" xmlns="http://www.w3.org/2000/svg"&gt;&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"&gt;&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"&gt;&lt;/path&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;This was also the time when IIT BHU reached out to me for a talk as part of a collab between their Astronomy and Open-Source clubs about Astronomy in tech and OSS. This was a  g r e a t  experience! I’ve always wanted to improve at public-speaking stuff and to finally pull off a satisfactory talk was a great experience. Also Prayash was a great host.&lt;/p&gt;
&lt;h3 id="beginning-with-the-project"&gt;Beginning with the Project
&lt;span&gt;
&lt;a href="https://exitflynn.github.io/blog/tags/gsoc/index.xml#beginning-with-the-project"&gt;
&lt;svg height="100%" viewbox="0 0 28 23" width="19" xmlns="http://www.w3.org/2000/svg"&gt;&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"&gt;&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"&gt;&lt;/path&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;My mentor, Nabil, had asked me to start by writing tests for the scraper, even if they may not return a -ve)for all the URLs it doesn’t support now.
Looking closely though, all the issues were due to limitations of the way regex is implemented for inputting URLs, i.e. since one of the main goals of the project was to remove regex and use parse instead, these tests would have proven to be quite redundant. I asked my mentors and understandably so, Nabil said that he doesn’t want me working on code that I might have to remove soon enough and said I can proceed to the rest of the rewrite.&lt;/p&gt;
&lt;p&gt;After that, I began reading up on what Metaclasses, Abstract Base Classes (ABCs), etc are, their advantages and how they can be implemented in python to decide which would be better for the purpose of the project. However, at this point I wasn’t really maintaining good communication with my mentors. When they asked me for any updates and then inquired about why I had been reading up on ABCs and such, they clarified that I should be able to improve the scraper without going that route.&lt;/p&gt;
&lt;p&gt;Had to take a couple of days off in between for unavoidable reasons.&lt;/p&gt;
&lt;p&gt;After that I took some calls with my mentors, clarifying details and trying to work things through together as I figured out what I should do next.
All the scraper // dataretriever clients require two strings, &lt;code&gt;baseurl&lt;/code&gt; and &lt;code&gt;pattern&lt;/code&gt; and I figure out a way to merge them somehow.
I looked into just what role the two of them had and found that &lt;code&gt;pattern&lt;/code&gt; was used only to parse data.
For example, When writing scraper clients, we require a baseurl and a pattern, an example from the NOAA Client:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0"&gt;&lt;code class="language-python"&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;baseurl &lt;span style="color: #f92672;"&gt;=&lt;/span&gt; &lt;span style="color: #e6db74;"&gt;r&lt;/span&gt;&lt;span style="color: #e6db74;"&gt;'ftp://ftp.ngdc.noaa.gov/STP/swpc_products/daily_reports/solar_region_summaries/%Y/%m/%Y%m&lt;/span&gt;&lt;span style="color: #e6db74;"&gt;%d&lt;/span&gt;&lt;span style="color: #e6db74;"&gt;SRS.txt'&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display: flex;"&gt;&lt;span&gt;pattern &lt;span style="color: #f92672;"&gt;=&lt;/span&gt; &lt;span style="color: #e6db74;"&gt;'&lt;/span&gt;&lt;span style="color: #e6db74;"&gt;{}&lt;/span&gt;&lt;span style="color: #e6db74;"&gt;/&lt;/span&gt;&lt;span style="color: #e6db74;"&gt;{year:4d}&lt;/span&gt;&lt;span style="color: #e6db74;"&gt;/&lt;/span&gt;&lt;span style="color: #e6db74;"&gt;{month:2d}&lt;/span&gt;&lt;span style="color: #e6db74;"&gt;/&lt;/span&gt;&lt;span style="color: #e6db74;"&gt;{year:4d}{month:2d}{day:2d}&lt;/span&gt;&lt;span style="color: #e6db74;"&gt;SRS.txt'&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Instead of passing both, we should be able to merge them into just one since the pattern string is conveying information that is already available in the baseurl.&lt;/p&gt;
&lt;p&gt;I figured it should be possible to transform &lt;code&gt;baseurl&lt;/code&gt; to &lt;code&gt;pattern&lt;/code&gt; and generate &lt;code&gt;pattern&lt;/code&gt; that way but halfway through I realised that it’d not be possible. However we should be able to convert a full &lt;code&gt;pattern&lt;/code&gt; to it’s &lt;code&gt;baseurl&lt;/code&gt; formatted counterpart.&lt;/p&gt;
&lt;p&gt;I remember writing out loud what I thought as I approached that problem:&lt;/p&gt;
&lt;h3 id="rubber-ducky-microblogging"&gt;rubber ducky microblogging?
&lt;span&gt;
&lt;a href="https://exitflynn.github.io/blog/tags/gsoc/index.xml#rubber-ducky-microblogging"&gt;
&lt;svg height="100%" viewbox="0 0 28 23" width="19" xmlns="http://www.w3.org/2000/svg"&gt;&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"&gt;&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"&gt;&lt;/path&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;now how do we include this transformation in our code?
we have mainly two places / files of concern.
&lt;code&gt;dataretriever/client.py&lt;/code&gt; and &lt;code&gt;scraper.py&lt;/code&gt;
at this point there are a couple of ways to go about it that come to my mind, all of them would however can be categorised as:
a) include the transformation in dr/client.py
b) include it in scraper.py&lt;/p&gt;
&lt;p&gt;before i get ahead of myself, it’s better to arrive at a concrete decision here, if that’s possible, to avoid having too much of overhead.&lt;/p&gt;
&lt;p&gt;case a:
pattern transforms in client and is then sent to scraper. this means the scraper still operates on strftime baseurl.
and when we want to call the parse function, instead of sending pattern as we do now, we can just send the original new format&lt;/p&gt;
&lt;p&gt;case b:
pass the new format to scraper. scraper converts it into strftime to use in all of its functions, and&lt;/p&gt;
&lt;p&gt;the second approach makes more sense, yeah.&lt;/p&gt;
&lt;p&gt;NOW
what’d be a nice way to incorporate this transform in the scraper file?&lt;/p&gt;
&lt;p&gt;So there have to be Two strings/patterns, throughout this codebase.
the strftime kind and the parse kind.
what we input is the parse kind (since we can convert this to strftime, and the other way around wasn’t possible)&lt;/p&gt;
&lt;p&gt;how to incorporate both strings? make them both private members of the Scraper class?&lt;/p&gt;
&lt;p&gt;some functions will be changed as a result of this&lt;/p&gt;
&lt;p&gt;like _URL_followsPattern&lt;/p&gt;
&lt;p&gt;okay so the plan of action is:
go add a transform function, call it in init
we’ll have a variable for the time_pattern, update pattern -&amp;gt; time_pattern wherever applicable.
rewrite using parse wherever applicable&lt;/p&gt;
&lt;p&gt;but this would take away from having a standard system and we’ll be defining our own set of names to name variables as.&lt;/p&gt;
&lt;p&gt;also a future plan can be to check for redundant functions / moving code.&lt;/p&gt;
&lt;h3 id="in-conclusion"&gt;in conclusion
&lt;span&gt;
&lt;a href="https://exitflynn.github.io/blog/tags/gsoc/index.xml#in-conclusion"&gt;
&lt;svg height="100%" viewbox="0 0 28 23" width="19" xmlns="http://www.w3.org/2000/svg"&gt;&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"&gt;&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"&gt;&lt;/path&gt;&lt;/path&gt;&lt;/svg&gt;
&lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;So as of right now, I’ve been working on &lt;a href="https://github.com/sunpy/sunpy/issues/7073"&gt;#7073&lt;/a&gt; and &lt;a href="https://github.com/sunpy/sunpy/pull/7077"&gt;PR #7077&lt;/a&gt;, more details on this issue and my proposed solution can be found in the issue description.&lt;/p&gt;
&lt;p&gt;This’ll be all for now, will be posting more in the future.&lt;/p&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2023/06/20230624_0133_exitflynn/</guid><pubDate>Sat, 24 Jun 2023 00:33:30 GMT</pubDate></item><item><title>Comparing memory performance of Vaex and Pandas</title><link>http://openastronomy.org/Universe_OA/posts/2023/06/20230624_0000_1someshverma/</link><dc:creator>Somesh Verma</dc:creator><description>&lt;p&gt;After completing all the changes to compute Spectrum using Vaex , I compared the memory used during the execution of the program . I used tracemalloc to compute memory uses to compute Spectrum .&lt;/p&gt;

&lt;h4 id="computing-the-spectrum"&gt;Computing the spectrum&lt;/h4&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;Following code is used , and memory maximum memory used during the execution of this code is recorded for Vaex and Pandas&lt;/p&gt;

&lt;div class="language-plaintext highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;
from radis import calc_spectrum
import tracemalloc
tracemalloc.start()

s, factory_s = calc_spectrum(1800, 2500,         # cm-1
molecule='H2O',
isotope='1,2,3',
pressure=1.01325,   # bar
Tgas=700,           # K
mole_fraction=0.1,
path_length=1,      # cm
databank='hitemp',  # or 'hitemp', 'geisa', 'exomol'
wstep='auto',
use_cached=False,
engine='pandas',
return_factory=True,
)

s.apply_slit(0.5, 'nm')       # simulate an experimental slit
s.plot('radiance')

print(tracemalloc.get_traced_memory())
tracemalloc.stop()

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id="results"&gt;Results&lt;/h4&gt;

&lt;p&gt;It can be seen from the graph below that Vaex takes very less memory space in comparison to Pandas.&lt;/p&gt;

&lt;p&gt;&lt;img alt="Vaex Comparison" src="https://1someshverma.github.io/images/vaexcomparison.png"&gt;&lt;/p&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2023/06/20230624_0000_1someshverma/</guid><pubDate>Fri, 23 Jun 2023 23:00:00 GMT</pubDate></item><item><title>Creating a new Data Structure for pyGnuastro</title><link>http://openastronomy.org/Universe_OA/posts/2023/06/20230620_0000_labeeb-7z/</link><dc:creator>Labib Asari</dc:creator><description>&lt;h3 id="background"&gt;Background&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://www.gnu.org/savannah-checkouts/gnu/gnuastro/gnuastro.html"&gt;GnuAstro&lt;/a&gt; is a powerful and comprehensive library designed to handle various data formats(FITS/TIFF/TXT and more) and perform a wide range of operations, all while maintaining consistency across its entire codebase.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;

&lt;p&gt;This is done by representing all the data (acquired via input or created internally), regardless of its type, in a single data structure which encompasses the core data as well as metadata. This greatly assists in mainting uniformity.
Internally all the data is represented in the form of a C struct : &lt;code class="language-plaintext highlighter-rouge"&gt;gal_data_t&lt;/code&gt;
The following image describes how it keeps the core data as well as metadata :
&lt;img alt="Code-Block1" src="https://labeeb-7z.github.io/Blogs/img/posts/creating-data-structure/gal_data_t.png"&gt;&lt;/p&gt;

&lt;p&gt;Explaining each attribute of this structure will require a seperate post of itself :). Instead I’ll focus on the main topic here : Since Im creating a python package for Gnuastro, and the &lt;code class="language-plaintext highlighter-rouge"&gt;gal_data_t&lt;/code&gt; is at the heart of this library, How do I represent this complex type in Python?!&lt;/p&gt;

&lt;p&gt;Normally we use Classes to define new and complex data types in Python, but hey.. I’m wrapping a C library in Python using the Python-C API. This means I write my wrappers in C!&lt;/p&gt;

&lt;p&gt;So the question comes down to how do I create a new type in Python using C language?&lt;/p&gt;

&lt;h3 id="creating-new-data-types-in-python-without-classes-and-objects"&gt;Creating New Data Types in Python Without Classes and Objects&lt;/h3&gt;

&lt;p&gt;Before I continue, I’ve to appreciate &lt;a href="https://numpy.org/"&gt;Numpy&lt;/a&gt; for the incredible peice of software it is, the more I understand it, the more it amazes me.&lt;/p&gt;

&lt;p&gt;C is not an Object Oriented Programming Language, but Python is.&lt;/p&gt;

&lt;p&gt;In case you didn’t know the most common implementation of Python (the one you most probably have) is written in C! It’s called CPython.&lt;/p&gt;

&lt;p&gt;This raises an obvious question, how does Python implement its whole OOP paradigm in C?&lt;/p&gt;

&lt;p&gt;This question also answers our question of how to represent &lt;code class="language-plaintext highlighter-rouge"&gt;gal_data_t&lt;/code&gt; in Python, because essentially they’re looking for the same thing.&lt;/p&gt;

&lt;p&gt;&lt;code class="language-plaintext highlighter-rouge"&gt;PyObject&lt;/code&gt; is the answer! To the Python interpreter(written in C) all the data types(built in as well as user defined) are of this type!&lt;/p&gt;

&lt;p&gt;and what is this &lt;code class="language-plaintext highlighter-rouge"&gt;PyObject&lt;/code&gt;? Its a simple struct in C.&lt;/p&gt;</description><category>gnuastro</category><guid>http://openastronomy.org/Universe_OA/posts/2023/06/20230620_0000_labeeb-7z/</guid><pubDate>Mon, 19 Jun 2023 23:00:00 GMT</pubDate></item><item><title>Implementation of the Kurucz database to Radis</title><link>http://openastronomy.org/Universe_OA/posts/2023/06/20230617_2033_menasrac/</link><dc:creator>Racim MENASRIA</dc:creator><description>&lt;p&gt;As planed in my last article, I started my project by adding a first database to Radis : Kurucz.&lt;/p&gt;
&lt;p&gt;I based my work on a existing class developed in Exojax. I reviewed the associated methods that allowed to download the data from the database, store it in numpy arrays and extract the key information from it for further calculation.&lt;/p&gt;
&lt;p&gt;By running a few examples on Exojax, I got familiar with the structure and nature of the data and key functions.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;However, I noticed a problem in the install command of Radis’s sister code Exojax while running theses examples. After further investigation with my mentors and the Exojax team, it appeared to be a jax problem so we couldn’t fix it for the moment.&lt;br&gt;Since I could only make them work on a wsl environment, I couldn’t afford to import jax libraries used in the AdbKurucz database implemented to Exojax. This is the reason why I had to adapt the structure of the data and methods and stick to Pandas dataframes and numpy arrays.&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;First try : using a DatabaseManager structure&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;As a explained it in the previous article, Radis has developed a special Class the handle the database processes. Since Kurucz is an atomic Database, I tried to implement it by making it inherit from the DatabaseManager class and setting the molecule parameter to “None”. Unfortunately, it led to many exceptions in the methods that I gave up on this idea.&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Second try : using Exojax methods without jax imports&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;This approach provided very nice results because the major part of the methods were already efficient. &lt;br&gt;Nevertheless I had some errors because of the data wasn’t loaded properly or syntax errors had broken a few parts of the code.&lt;/p&gt;
&lt;p&gt;I finally managed to load, store and use the data from Kurucz.&lt;/p&gt;
&lt;p&gt;Then I added an example to show how this new database can be used.&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*oJXYNuWaqdZFCpuhYTNSjw.png"&gt;&lt;/figure&gt;&lt;p&gt;This is the first spectrum that I obtained from the Kurucz database for Fe.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;A bit more explanations:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The population of the lower energy level of a given transition is the number of atoms that are in that energy state at any given time. So if you have a large population in a certain energy state, you have a lot of atoms that are able to make the transition and therefore emit a photon. Einstein’s coefficient A for a particular transition is a measure of the probability of that transition occurring. So if A is large, then each atom has a high chance of making the transition and emitting a photon. Thus, the intensity of the spectral line (i.e. the number of photons emitted per unit time) is proportional to both the population of the lower energy level (the number of atoms capable of making the transition) and to A (the probability that each atom actually makes the transition). So the intensity can be approximately represented as A * population.&lt;/p&gt;
&lt;p&gt;The users can chose the temperature and the function then interpolates the values from the database and plots the spectrum.&lt;/p&gt;
&lt;p&gt;In order to generalize this to all the atoms and ions of the database, I had to adjust the function load_pf_Barklem2016() from Exojax and fix an error in the way the partition functions were extracted.&lt;/p&gt;
&lt;p&gt;Now I can load the data and use it properly. For Kurucz’s data, each file corresponds to a single species of atom only. For example, “gf2600.all” is dedicated to absorption lines of “neutral iron atoms”. The “26” is the atomic number of iron, followed by a “00” indicating zero ionization (=neutral; Fe I). For example, if you want to use spectral lines of singly-ionized sodium (Na II or Na+), you should download “gf1101.all”.&lt;/p&gt;
&lt;p&gt;Here is another example for Ca.&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*q_748Zt_K4rqW5fWtFAdTQ.png"&gt;&lt;/figure&gt;&lt;h4&gt;&lt;strong&gt;What is next ?&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;I will end up this week by adding a few tests to ensure my code doesn’t break any part of the Radis architecture and may go for a PR in the next days.&lt;/p&gt;
&lt;p&gt;Then the next step for Week 4 will be to implement the TheoReTS database to Radis .&lt;/p&gt;
&lt;img alt="" height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=27c2724fde74" width="1"&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2023/06/20230617_2033_menasrac/</guid><pubDate>Sat, 17 Jun 2023 19:33:30 GMT</pubDate></item><item><title>Refactoring code for calculating Spectrum Using Vaex dataframe</title><link>http://openastronomy.org/Universe_OA/posts/2023/06/20230616_0000_1someshverma/</link><dc:creator>Somesh Verma</dc:creator><description>&lt;p&gt;After the community bonding period , I continued refactoring the code for vaex .
I have the following the things in this period&lt;/p&gt;

&lt;!-- TEASER_END --&gt;
&lt;ul&gt;
&lt;li&gt;Test cases for fetch_databank() and load_databank() functions&lt;/li&gt;
&lt;li&gt;Replaced the portion of code which is different for Vaex as compared with Pandas&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="test-cases-for-loading-dataframe-in-vaex-dataframe-format"&gt;Test Cases for loading dataframe in Vaex dataframe format&lt;/h4&gt;

&lt;p&gt;Test Cases are written to test the following :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Number of columns are same in both Vaex dataframe and Pandas dataframe&lt;/li&gt;
&lt;li&gt;Number of lines in same in both the dataframe&lt;/li&gt;
&lt;li&gt;Compared the value of some of the column with corresponding the column value&lt;/li&gt;
&lt;li&gt;Calculated the spectrum of CO molecule under equilibrium and compared both the spectrum are the same&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;One of the test case added is following , I have simply fetched dataframe in Vaex dataframe format and pandas , then compared the if the above conditions are satisfied are not .&lt;/p&gt;
&lt;div class="language-plaintext highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;def test_df_from_vaex_and_pandas():
from radis.lbl import SpectrumFactory

sf = SpectrumFactory(
2284,
2300,
wstep=0.001,  # cm-1
pressure=20 * 1e-3,  # bar
cutoff=0,
path_length=0.1,
mole_fraction=400e-6,
molecule="CO",
isotope="1,2",
medium="vacuum",
truncation=5,
verbose=0,
)
sf.engine = 'vaex'
sf.warnings["MissingSelfBroadeningWarning"] = "ignore"
# Testing Hitran
sf.fetch_databank("hitran", memory_mapping_engine='vaex', output='pandas', load_columns="all")
df_pandas = sf.df0

sf.fetch_databank("hitran", memory_mapping_engine='vaex', output='vaex', load_columns="all")
df_vaex = sf.df0

assert df_vaex[0][0] == df_pandas.iloc[0]["wav"]

columns_vaex = df_vaex.column_names
columns_pandas = df_pandas.column
comparison = (df_vaex.column_names == df_pandas.columns)

assert comparison.all()

# Testing Hitemp
sf.fetch_databank("hitemp", memory_mapping_engine='vaex', output='pandas', load_columns="all")
df_pandas = sf.df0

sf.fetch_databank("hitemp", memory_mapping_engine='vaex', output='vaex', load_columns="all")
df_vaex = sf.df0

assert df_vaex[0][0] == df_pandas.iloc[0]["wav"]

columns_vaex = df_vaex.column_names
columns_pandas = df_pandas.column
comparison = (df_vaex.column_names == df_pandas.columns)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id="refactoring-the-code-to-calculate-the-spectrum-using-vaex-dataframe"&gt;Refactoring the code to calculate the Spectrum using Vaex dataframe&lt;/h4&gt;

&lt;p&gt;To calculate the spectrum using the Vaex dataframe ,I had to made changes to the following&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;radis/api/hitranapi.py&lt;/li&gt;
&lt;li&gt;radis/api/cdsdapi.py&lt;/li&gt;
&lt;li&gt;radis/api/hdf5.py&lt;/li&gt;
&lt;li&gt;radis/api/cache_files.py&lt;/li&gt;
&lt;li&gt;radis/api/tools.py&lt;/li&gt;
&lt;li&gt;radis/io/exomol.py&lt;/li&gt;
&lt;li&gt;radis/io/geisa.py&lt;/li&gt;
&lt;li&gt;radis/io/hitran.py&lt;/li&gt;
&lt;li&gt;radis/io/query.py&lt;/li&gt;
&lt;li&gt;radis/lbl/base.py&lt;/li&gt;
&lt;li&gt;radis/lbl/broadening.py&lt;/li&gt;
&lt;li&gt;radis/lbl/calc.py&lt;/li&gt;
&lt;li&gt;radis/lbl/loader.py&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These are all files which are involved in calculating the Spectrum of molecule(s) ,from loading to calculating . I have only refactord the part that is required to Equilibrium Calculations .I kept the previous implementation of Pandas and just added code for Vaex .&lt;/p&gt;

&lt;p&gt;For loading the main changes are done in hitranapi.py for parsing the molecules and i also had to spend a lot time on it to find the equivalent operations functions in Vaex as in Pandas .
Finally , i was able to resolve the issue and below is final code that worked for me .&lt;/p&gt;

&lt;div class="language-plaintext highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;def _parse_HITRAN_class1(df, verbose=True,dataframe_type="pandas"):
r"""Diatomic molecules: CO, HF, HCl, HBr, HI, N2, NO+


Parameters
----------
df: pandas Dataframe
lines read from a HITRAN-like database


Notes
-----
HITRAN syntax [1]_ :

&amp;gt;&amp;gt;&amp;gt;       v
&amp;gt;&amp;gt;&amp;gt;  13x I2

References
----------

.. [1] `Table 3 of Rothman et al. HITRAN 2004 &amp;lt;https://www.cfa.harvard.edu/hitran/Download/HITRAN04paper.pdf&amp;gt;`__


"""

if dataframe_type == "vaex":
# 1. Parse

extracted_values = df['globu'].str.extract_regex(pattern = r"[ ]{13}(?P&amp;lt;vu&amp;gt;[\d ]{2})")
df['vu'] = extracted_values.apply(lambda x : x.get('globu'))
df['vu'] = df.evaluate(df['vu'])

extracted_values = df['globl'].str.extract_regex(pattern = r"[ ]{13}(?P&amp;lt;vl&amp;gt;[\d ]{2})")
df['vl'] = extracted_values.get(df['globl'])
df['vl'] = df.evauate(df['vl'])

# 2. Convert to numeric
cast_to_int64_with_missing_values(df, ["vu" ,"vl"], dataframe_type=dataframe_type)

# 3. Clean
del df["globu"]
del df["globl"]

return df
elif dataframe_type == "pandas":
# 1. Parse
dgu = df["globu"].astype(str).str.extract(r"[ ]{13}(?P&amp;lt;vu&amp;gt;[\d ]{2})", expand=True)
dgl = df["globl"].astype(str).str.extract(r"[ ]{13}(?P&amp;lt;vl&amp;gt;[\d ]{2})", expand=True)

# 2. Convert to numeric
cast_to_int64_with_missing_values(dgu, ["vu"],dataframe_type=dataframe_type)
cast_to_int64_with_missing_values(dgl, ["vl"],dataframe_type=dataframe_type)

# 3. Clean
del df["globu"]
del df["globl"]

return pd.concat([df, dgu, dgl], axis=1)
else:
raise NotImplementedError(dataframe_type)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For other part of the code , i added an additional parameter self.dataframe_type and whenever operations are different for vaex and pandas ,I used it to execute the part of code for the respective dataframe type as whether it is Vaex or Pandas .&lt;/p&gt;

&lt;p&gt;#####Spectrum using Vaex and Pandas&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Code used&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="language-plaintext highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;from radis import calc_spectrum

s, factory_s = calc_spectrum(1800, 2500,         # cm-1
molecule='H2O',
isotope='1,2,3',
pressure=1.01325,   # bar
Tgas=700,           # K
mole_fraction=0.1,
path_length=1,      # cm
databank='hitemp',  # or 'hitemp', 'geisa', 'exomol'
wstep='auto',
use_cached=False,
engine='vaex',
return_factory=True,
)

s.apply_slit(0.5, 'nm')       # simulate an experimental slit
s.plot('radiance')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id="using-vaex"&gt;Using Vaex&lt;/h6&gt;
&lt;p&gt;&lt;img alt="spectrum using vaex" src="https://1someshverma.github.io/images/specturm-using-vaex.png"&gt;&lt;/p&gt;

&lt;h6 id="using-pandas"&gt;Using Pandas&lt;/h6&gt;
&lt;p&gt;As i also kept the Pandas implementation , spectrum calculated using that is&lt;/p&gt;

&lt;p&gt;&lt;img alt="spectrum using pandas" src="https://1someshverma.github.io/images/specturm-using-vaex.png"&gt;&lt;/p&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2023/06/20230616_0000_1someshverma/</guid><pubDate>Thu, 15 Jun 2023 23:00:00 GMT</pubDate></item></channel></rss>