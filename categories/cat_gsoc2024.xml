<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Universe OpenAstronomy (Posts about gsoc2024)</title><link>http://openastronomy.org/Universe_OA/</link><description></description><atom:link href="http://openastronomy.org/Universe_OA/categories/cat_gsoc2024.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Fri, 12 Jul 2024 01:02:42 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>The project is almost finished</title><link>http://openastronomy.org/Universe_OA/posts/2024/07/20240711_1938_ahmedhosssam/</link><dc:creator>Ahmed Hossam</dc:creator><description>&lt;p&gt;So, after I finished the main refactoring and the documentation strings, I started the testing phase.&lt;br&gt;
I started with the smallest functions that don't call any non-tested function, and then went to the bigger functions.&lt;/p&gt;

&lt;!-- TEASER_END --&gt;
&lt;p&gt;After finishing the main unit tests, I had a problem, the columns in the input data from the hek have different units, for example, for &lt;code&gt;event_coord1&lt;/code&gt; we have some rows with degrees and others with arcsecond, and the result would be a column with one unit, the degrees are converted into arcseconds or vice versa. So me and my mentor decided to:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Merge &lt;code&gt;event_coord1&lt;/code&gt; and &lt;code&gt;event_coord2&lt;/code&gt; and &lt;code&gt;event_coord3&lt;/code&gt; into one &lt;code&gt;SkyCoord&lt;/code&gt; object for every row.
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight js-code-highlight"&gt;
&lt;pre class="highlight python"&gt;&lt;code&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;is_coord_prop&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;event_coord_col&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nf"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="s"&gt;event_coord1&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="p"&gt;])):&lt;/span&gt;
&lt;span class="n"&gt;unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;get_unit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="s"&gt;event_coordunit&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="n"&gt;coord1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="s"&gt;event_coord1&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;coord2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="s"&gt;event_coord2&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;coord3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="s"&gt;event_coord3&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="s"&gt;helioprojective&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;unit&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;arcsec&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="s"&gt;icrs&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;coord3&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;event_coord&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;SkyCoord&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coord1&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;unit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;coord2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;unit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;coord3&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;unit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;event_coord&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;SkyCoord&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coord1&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;unit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;coord2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;unit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;event_coord_col&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;event_coord&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;event_coord_col&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Column&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;event_coord_col&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="s"&gt;event_coord&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="s"&gt;event_coord1&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="s"&gt;event_coord2&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="s"&gt;event_coord3&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;add_column&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;event_coord_col&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;The other columns that has multiple units would be converted into astropy column first and then added to the table
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight js-code-highlight"&gt;
&lt;pre class="highlight python"&gt;&lt;code&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;attribute&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;is_chaincode&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="n"&gt;new_column&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Column&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_column&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;name&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;]],&lt;/span&gt; &lt;span class="n"&gt;dtype&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Quantity&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;


&lt;p&gt;After this, I started a mission of checking the resulting columns and comparing them to the input and also to the expected results. And here I saw some surprises:&lt;br&gt;
There are columns that don't even exist in the &lt;a href="https://www.lmsal.com/hek/VOEvent_Spec.html" rel="noopener noreferrer"&gt;HEK Feature/Event Types definitions&lt;br&gt;
&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;hgc_coord&lt;/li&gt;
&lt;li&gt;hpc_coord&lt;/li&gt;
&lt;li&gt;hgs_coord&lt;/li&gt;
&lt;li&gt;hrc_coord&lt;/li&gt;
&lt;li&gt;hgc_boundcc&lt;/li&gt;
&lt;li&gt;hpc_boundcc&lt;/li&gt;
&lt;li&gt;hgs_boundcc&lt;/li&gt;
&lt;li&gt;hrc_boundcc&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So I had to add them into &lt;code&gt;coord_properties.json&lt;/code&gt; file with double-checking the frames.&lt;/p&gt;

&lt;p&gt;hgc_coord, hpc_coord, hgs_coord, hrc_coord are points, so they had to be converted into &lt;code&gt;PointSkyRegion&lt;/code&gt;.&lt;br&gt;
And they were supported in &lt;code&gt;parse_chaincode&lt;/code&gt;:&lt;br&gt;
&lt;/p&gt;

&lt;div class="highlight js-code-highlight"&gt;
&lt;pre class="highlight python"&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;parse_chaincode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;attribute&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;unit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;attribute&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;is_point&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="n"&gt;coordinates&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;POINT(&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sh"&gt;""&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nf"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;)&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sh"&gt;""&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nf"&gt;split&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;coord_list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nf"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coordinate&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;coordinate&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;coordinates&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;coord_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="n"&gt;coord1_unit&lt;/span&gt;
&lt;span class="n"&gt;coord_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="n"&gt;coord2_unit&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;attribute&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;frame&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;heliocentric&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;center_sky&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;SkyCoord&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coord_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;coord_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coord_list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AU&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;obstime&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;observer&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;observer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;representation_type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;cylindrical&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;frame&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nc"&gt;PolygonSkyRegion&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vertices&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;center_sky&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;center_sky&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;SkyCoord&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coord_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;coord_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;obstime&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;observer&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;observer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;frame&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nc"&gt;PointSkyRegion&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;center&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;center_sky&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;



&lt;p&gt;So far so good.&lt;/p&gt;

&lt;p&gt;Also, some tests in &lt;code&gt;test_hek&lt;/code&gt; were simplified, instead of checking if the object is instance of PolygonSkyRegion or PointSkyRegion, we can just check if it's instance of SkyRegion which is the base class for all regions defined in celestial coordinates.&lt;/p&gt;

&lt;p&gt;Also, another update to &lt;code&gt;parse_chaincode&lt;/code&gt;, the observation time were added to the parameter to be added to all the region objects. We used the column &lt;code&gt;event_starttime&lt;/code&gt; to specify the obstime of the event. And we also I added the observer as &lt;code&gt;earth&lt;/code&gt;, I still don't know if this would be correct for the different conditions and different queries of the hek, but we will see, and also I wrote a comment to highlight the assumption.&lt;/p&gt;

&lt;p&gt;Here is the complete implementation of &lt;code&gt;parse_chaincode&lt;/code&gt;:&lt;br&gt;
&lt;/p&gt;

&lt;div class="highlight js-code-highlight"&gt;
&lt;pre class="highlight python"&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;parse_chaincode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;attribute&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;unit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="sh"&gt;"""&lt;/span&gt;&lt;span class="s"&gt;
Parses a string representation of coordinates and convert them into a PolygonSkyRegion object
using units based on the specified coordinate frame.

Parameters
----------
value : str
A polygon defined using vertices in sky coordinates.
attribute : dict
An object from &lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;coord_properties.json&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;
unit : str
The unit of the coordinates
time : `~astropy.time.core.Time`
An event_starttime row parsed into astropy time.

Returns
-------
`PolygonSkyRegion`
A polygon defined using vertices in sky coordinates.

Raises
------
IndexError
Because ``value`` does not contain the expected &lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="s"&gt;((&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="s"&gt; and &lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="s"&gt;))&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="s"&gt; substrings.
UnitConversionError
Because the units set by ``coord1_unit`` or ``coord2_unit`` are incompatible with the values being assigned.
&lt;/span&gt;&lt;span class="sh"&gt;"""&lt;/span&gt;
&lt;span class="n"&gt;observer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="s"&gt;earth&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt; &lt;span class="c1"&gt;# There is an assumption that earth is the observer.
&lt;/span&gt;    &lt;span class="n"&gt;coord1_unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;deg&lt;/span&gt;
&lt;span class="n"&gt;coord2_unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;deg&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;attribute&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;frame&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;helioprojective&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;coord1_unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;arcsec&lt;/span&gt;
&lt;span class="n"&gt;coord2_unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;arcsec&lt;/span&gt;
&lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;attribute&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;frame&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;heliocentric&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;coord1_unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;R_sun&lt;/span&gt; &lt;span class="c1"&gt;# Nominal solar radius
&lt;/span&gt;    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;attribute&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;frame&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;icrs&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;coord1_unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;get_unit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;unit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;coord2_unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;get_unit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;unit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;attribute&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;is_point&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="n"&gt;coordinates&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;POINT(&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sh"&gt;""&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nf"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;)&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sh"&gt;""&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nf"&gt;split&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;coord_list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nf"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coordinate&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;coordinate&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;coordinates&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;coord_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="n"&gt;coord1_unit&lt;/span&gt;
&lt;span class="n"&gt;coord_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="n"&gt;coord2_unit&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;attribute&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;frame&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;heliocentric&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;center_sky&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;SkyCoord&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coord_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;coord_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coord_list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AU&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;obstime&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;observer&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;observer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;representation_type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;cylindrical&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;frame&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nc"&gt;PolygonSkyRegion&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vertices&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;center_sky&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;center_sky&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;SkyCoord&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coord_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;coord_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;obstime&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;observer&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;observer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;frame&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nc"&gt;PointSkyRegion&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;center&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;center_sky&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;coordinates_str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="s"&gt;((&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="nf"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="s"&gt;))&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;coord1_list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nf"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coord&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;split&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;coord&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;coordinates_str&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="s"&gt;,&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;coord1_unit&lt;/span&gt;
&lt;span class="n"&gt;coord2_list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nf"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coord&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;split&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;coord&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;coordinates_str&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="s"&gt;,&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;coord2_unit&lt;/span&gt;
&lt;span class="n"&gt;vertices&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;attribute&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;frame&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;heliocentric&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;vertices&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;SkyCoord&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coord1_list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;coord2_list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coord1_list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AU&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;obstime&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;observer&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;observer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;representation_type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;cylindrical&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;heliocentric&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;vertices&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;SkyCoord&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coord1_list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;coord2_list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;obstime&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;observer&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;observer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;frame&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nc"&gt;PolygonSkyRegion&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vertices&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;vertices&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;



&lt;p&gt;One major outcome of this project was to make using hek and acquiring data from it easy, and this happened when I saw some errors from the CI and when I checked it I saw that one example of &lt;code&gt;overplot_hek_polygon.py&lt;/code&gt; should be modified due to the interface changing and the returned data types.&lt;br&gt;
This was the initial using of hek in this example:&lt;br&gt;
&lt;/p&gt;

&lt;div class="highlight js-code-highlight"&gt;
&lt;pre class="highlight python"&gt;&lt;code&gt;&lt;span class="n"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;responses&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;response_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;p1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;hpc_boundcc&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;p2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="s"&gt;,&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;p3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt; &lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;p2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;ch_date&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;parse_time&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="s"&gt;event_starttime&lt;/span&gt;&lt;span class="sh"&gt;'&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="n"&gt;ch_boundary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;responses&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;response_index&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;hpc_boundcc&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="c1"&gt;##############################################################################
# The coronal hole was detected at different time than the AIA image was
# taken so we need to rotate it to the map observation time.
&lt;/span&gt;
&lt;span class="n"&gt;ch_boundary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;SkyCoord&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nf"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]),&lt;/span&gt; &lt;span class="nf"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;arcsec&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;p3&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
&lt;span class="n"&gt;obstime&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ch_date&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;observer&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;earth&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Helioprojective&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;rotated_ch_boundary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;solar_rotate_coordinate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ch_boundary&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;aia_map&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;



&lt;p&gt;And now it became this:&lt;br&gt;
&lt;/p&gt;

&lt;div class="highlight js-code-highlight"&gt;
&lt;pre class="highlight python"&gt;&lt;code&gt;&lt;span class="n"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;responses&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;response_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;ch_boundary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;responses&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;response_index&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="s"&gt;hpc_boundcc&lt;/span&gt;&lt;span class="sh"&gt;"&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;vertices&lt;/span&gt;

&lt;span class="c1"&gt;# The coronal hole was detected at different time than the AIA image was
# taken so we need to rotate it to the map observation time.
&lt;/span&gt;
&lt;span class="n"&gt;rotated_ch_boundary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;solar_rotate_coordinate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ch_boundary&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;aia_map&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;



&lt;p&gt;Yeah, and that's it.&lt;br&gt;
The remaining parts are writing the user documentation, and double-checking the returned data from different events and different queries.&lt;/p&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2024/07/20240711_1938_ahmedhosssam/</guid><pubDate>Thu, 11 Jul 2024 18:38:21 GMT</pubDate></item><item><title>Midterm Evaluations Are Close!</title><link>http://openastronomy.org/Universe_OA/posts/2024/07/20240707_1602_nucleongodx/</link><dc:creator>Manit Singh</dc:creator><description>&lt;p&gt;So, in the past two weeks, upon discussion with my mentors, I started working on the stretch goal, which involves using Astroquery’s TAP Plus for making the URL calls. Additionally, I had to clean up some code and remove the instruments SPICE and PHI from returning wavelength data due to their individual issues.&lt;/p&gt;
&lt;p&gt;For SPICE, the `wavemin’ and `wavemax` values are only available for the first spectral window in SOAR, so the data is not entirely representative of what a user might be searching for. Similarly, for PHI, the issue is that two different units are used to represent wavelength, which results in very&lt;br&gt;different `wavemin’ and `wavemax` data due to the data being in both angstrom and nanometer units. Unfortunately, this is not specified anywhere in SOAR, so to ensure that `sunpy-soar` does not&lt;br&gt;return any misleading data to the user, we’ve decided to exclude the wavelength data for these instruments.&lt;/p&gt;
&lt;p&gt;Coming to the change in table fetching methods. TAP Plus basically uses SQL to fetch tables, which is different from the normal TAP that uses ADQL to fetch tables. This avoids the entire process of manually constructing Astropy tables after calling the SOAR API with TAP.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;For comparison, this is how the method looks with TAP:&lt;/p&gt;
&lt;pre&gt;@staticmethod&lt;br&gt;    def _do_search(query):&lt;br&gt;        """&lt;br&gt;        Query the SOAR server with a single query.&lt;br&gt;&lt;br&gt;        Parameters&lt;br&gt;        ----------&lt;br&gt;        query : list[str]&lt;br&gt;            List of query items.&lt;br&gt;&lt;br&gt;        Returns&lt;br&gt;        -------&lt;br&gt;        astropy.table.QTable&lt;br&gt;            Query results.&lt;br&gt;        """&lt;br&gt;        tap_endpoint = "http://soar.esac.esa.int/soar-sl-tap/tap"&lt;br&gt;        payload = SOARClient._construct_payload(query)&lt;br&gt;        # Need to force requests to not form-encode the parameters&lt;br&gt;        payload = "&amp;amp;".join([f"{key}={val}" for key, val in payload.items()])&lt;br&gt;        # Get request info&lt;br&gt;        r = requests.get(f"{tap_endpoint}/sync", params=payload)&lt;br&gt;        log.debug(f"Sent query: {r.url}")&lt;br&gt;        r.raise_for_status()&lt;br&gt;&lt;br&gt;        # Do some list/dict wrangling&lt;br&gt;        names = [m["name"] for m in r.json()["metadata"]]&lt;br&gt;        info = {name: [] for name in names}&lt;br&gt;&lt;br&gt;        for entry in r.json()["data"]:&lt;br&gt;            for i, name in enumerate(names):&lt;br&gt;                info[name].append(entry[i])&lt;br&gt;&lt;br&gt;        if len(info["begin_time"]):&lt;br&gt;            info["begin_time"] = parse_time(info["begin_time"]).iso&lt;br&gt;            info["end_time"] = parse_time(info["end_time"]).iso&lt;br&gt;&lt;br&gt;        result_table = astropy.table.QTable(&lt;br&gt;            {&lt;br&gt;                "Instrument": info["instrument"],&lt;br&gt;                "Data product": info["descriptor"],&lt;br&gt;                "Level": info["level"],&lt;br&gt;                "Start time": info["begin_time"],&lt;br&gt;                "End time": info["end_time"],&lt;br&gt;                "Data item ID": info["data_item_id"],&lt;br&gt;                "Filename": info["filename"],&lt;br&gt;                "Filesize": info["filesize"],&lt;br&gt;                "SOOP Name": info["soop_name"],&lt;br&gt;            },&lt;br&gt;        )&lt;br&gt;        if "detector" in info:&lt;br&gt;            result_table["Detector"] = info["detector"]&lt;br&gt;        if "wavelength" in info:&lt;br&gt;            result_table["Wavelength"] = info["wavelength"]&lt;br&gt;        result_table.sort("Start time")&lt;br&gt;        return result_table&lt;/pre&gt;&lt;p&gt;This is how the method looks with Astroquery TAP plus.&lt;/p&gt;
&lt;pre&gt;`def _do_search(query):&lt;br&gt;        """&lt;br&gt;        Query the SOAR server with a single query.&lt;br&gt;&lt;br&gt;        Parameters&lt;br&gt;        ----------&lt;br&gt;        query : list[str]&lt;br&gt;            List of query items.&lt;br&gt;&lt;br&gt;        Returns&lt;br&gt;        -------&lt;br&gt;        astropy.table.Table&lt;br&gt;            Query results.&lt;br&gt;        """&lt;br&gt;        tap_endpoint = "http://soar.esac.esa.int/soar-sl-tap/tap"&lt;br&gt;        sql_query = SOARClient._construct_payload(query)&lt;br&gt;        soar = TapPlus(url=tap_endpoint)&lt;br&gt;        job = soar.launch_job_async(sql_query)&lt;br&gt;        results = job.results&lt;br&gt;        new_colnames = {&lt;br&gt;            "instrument": "Instrument",&lt;br&gt;            "descriptor": "Data product",&lt;br&gt;            "level": "Level",&lt;br&gt;            "begin_time": "Start time",&lt;br&gt;            "end_time": "End time",&lt;br&gt;            "filename": "Filename",&lt;br&gt;            "filesize": "Filesize",&lt;br&gt;            "soop_name": "SOOP Name",&lt;br&gt;        }&lt;br&gt;        new_colnames.update({k: k.capitalize() for k in ["wavelength", "detector"] if k in results.colnames})&lt;br&gt;        for old_name, new_name in new_colnames.items():&lt;br&gt;            results.rename_column(old_name, new_name)&lt;br&gt;        results.sort("Start time")&lt;br&gt;        return results&lt;/pre&gt;&lt;p&gt;Even the query construction methods, they looks a lot more cleaner. As the final query generated is an SQL query not an ADQL query.&lt;/p&gt;
&lt;img alt="" height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=459d99d953ff" width="1"&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2024/07/20240707_1602_nucleongodx/</guid><pubDate>Sun, 07 Jul 2024 15:02:57 GMT</pubDate></item><item><title>Blog 3: Side Quests Week</title><link>http://openastronomy.org/Universe_OA/posts/2024/07/20240703_1159_deus1704/</link><dc:creator>Deus1704</dc:creator><description>&lt;p&gt;While the mentors are waiting for community reviews on the new coalignment API, I’ve been diving into some fun side quests.&lt;/p&gt;
&lt;h3 id="side-quest-1-asda-examplehttpsgithubcomsunpysunkit-imagepull218"&gt;Side Quest 1: &lt;a href="https://github.com/sunpy/sunkit-image/pull/218"&gt;ASDA Example&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The long-needed &lt;a href="https://doi.org/10.3847/1538-4357/aabd34"&gt;Automated Swirl Detection Algorithm (ASDA)&lt;/a&gt; example gallery in the sunkit-image is now ready. The ASDA module is for identifying the swirls or vortices in the 2D flow field of the solar atmosphere. ASDA offers a robust tool for detecting and analyzing the vortices in the solar atmosphere.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;Swirls in the solar atmosphere provide insights into dynamic solar processes such as solar flares and coronal mass ejections. Detecting and analyzing these swirls helps understand the mechanisms driving these solar activities.&lt;/p&gt;
&lt;p&gt;The Gamma(Γ1 &amp;amp; Γ2) values are used for identifying the vortex center and the vortex edges respectively.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gamma1 (Γ1): Identifies vortex centers by quantifying rotational motion.&lt;/li&gt;
&lt;li&gt;Gamma2 (Γ2): Detects vortex edges by measuring the coherence of swirling motion.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These can be visualised as;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;&lt;img alt="Gamma Visualization" src="https://deus1704.vercel.app/images/gammas.png"&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;Gamma values (Γ1 &amp;amp; Γ2)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Using these, the final map with the swirls identified looks like:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;&lt;img alt="Swirl Map " src="https://deus1704.vercel.app/images/detected_swirls.png"&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;Swirl Map with Velocity Field&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The swirl map is crucial for visualizing fluid flow dynamics in the solar atmosphere, helping to identify the distribution, size, and characteristics of vortices.&lt;/p&gt;
&lt;p&gt;Magnifying a particular section of these for better understanding of the streamlines:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;&lt;img alt="Magnified Swirl Map " src="https://deus1704.vercel.app/images/magnified_swirls.png"&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;Magnified Swirl Map Region with Streamlines&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Magnifying a specific region and overlaying streamlines allows for detailed analysis of flow patterns around swirls, aiding in understanding solar atmospheric dynamics and the interactions between different vortices.&lt;/p&gt;
&lt;h3 id="side-quest-2-rotation-matrixhttpsgithubcomsunpysunpypull7452"&gt;Side Quest 2: &lt;a href="https://github.com/sunpy/sunpy/pull/7452"&gt;Rotation Matrix&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;One of my very first pull requests in SunPy received reviews after a long hiatus. The feedback highlighted some implementation issues with the way the SpicePy API was being used. For instance, the sxform function only accepts a single ephemeris time, which required a workaround to obtain the correct state transformation matrix.
With the invaluable help of Albert, these issues have been resolved and the test cases have been updated accordingly.&lt;/p&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2024/07/20240703_1159_deus1704/</guid><pubDate>Wed, 03 Jul 2024 10:59:31 GMT</pubDate></item><item><title>Filling the Temporal Gaps in AGN Light Curve Data</title><link>http://openastronomy.org/Universe_OA/posts/2024/06/20240630_2331_lucasmg18/</link><dc:creator>Lucas Martin Garcia</dc:creator><description>&lt;p&gt; &lt;strong&gt;Introduction to the Challenge&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In our ongoing quest to understand Active Galactic Nuclei (AGNs), handling the discontinuous nature of AGN light curve data remains the main goal. The gaps in observation data, caused by unavoidable operational and environmental constraints, obscure the complete picture of these AGN data. To address several methods are taken into account to approach the temporal data interpolation, combining traditional techniques with advanced machine learning models.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Traditional Interpolation Techniques&lt;/strong&gt;&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;The basic Interpolation Methods include:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Linear Interpolation:&lt;/strong&gt; Useful for filling short gaps where changes between points are expected to be gradual and linear.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Polynomial Interpolation:&lt;/strong&gt; Offers a more flexible approach for non-linear data, providing smoother estimates that can better reflect inherent variabilities in AGN light emissions.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;These techniques are fast and effective for smaller, simpler gaps but often fall short when dealing with larger or more complex interruptions in data.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Advanced Machine Learning Techniques&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For more substantial gaps or when high fidelity to complex light curve dynamics is crucial, some machine learning algorithms are:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Recurrent Neural Networks (RNNs):&lt;/strong&gt; These are particularly adept at modeling time-series data, capturing dependencies across time steps to predict missing observations with a high degree of accuracy.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Generative Adversarial Networks (GANs):&lt;/strong&gt; By training GANs on existing data, we can generate new data points that not only fill larger gaps but also maintain statistical consistency with observed data.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Moving Forward&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The integration of these methods has already shown promising results in other fields and applications. As we refine these techniques, we aim not only to improve the quality of data but also to deepen our understanding of the underlying physical processes of AGNs.&lt;/p&gt;
&lt;p&gt;Our journey into the light curves of AGNs is as much about improving our observational tools and techniques as it is about exploring the universe's mysteries. By bridging these data gaps, we hope to bring clarity to the complexities of galaxy evolution and contribute to the broader astronomical community.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conclusion&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The challenge of incomplete data is not unique to astronomy but is a common issue in various scientific domains. Our interdisciplinary approach has obtained already good results in other fields where data integrity impacts the quality of research outcomes.&lt;/p&gt;</description><category>irsa-fornax</category><guid>http://openastronomy.org/Universe_OA/posts/2024/06/20240630_2331_lucasmg18/</guid><pubDate>Sun, 30 Jun 2024 22:31:00 GMT</pubDate></item><item><title>Partition functions</title><link>http://openastronomy.org/Universe_OA/posts/2024/06/20240630_0000_code29563/</link><dc:creator>code29563</dc:creator><description>&lt;p&gt;Support has been added for the species-specific partition functions that are usually included along with the new linelists. In doing so, a new config parameter was added to allow the user to enable RADIS to automatically modify the local database files and update the config file accordingly.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2024/06/20240630_0000_code29563/</guid><pubDate>Sat, 29 Jun 2024 23:00:00 GMT</pubDate></item><item><title>Midterm evaluation are coming near</title><link>http://openastronomy.org/Universe_OA/posts/2024/06/20240628_1734_kartikmandar/</link><dc:creator>Kartik Mandar</dc:creator><description>&lt;p&gt; MidTerm evaluations are near the corner, I guess I am moving well with my project. I am hoping to do certain functionality before Monday and present that to my mentor. I still have one week more after that before the MidTerm evaluations. Let's see how it all goes!!&lt;/p&gt;
&lt;!-- TEASER_END --&gt;</description><category>stingray</category><guid>http://openastronomy.org/Universe_OA/posts/2024/06/20240628_1734_kartikmandar/</guid><pubDate>Fri, 28 Jun 2024 16:34:00 GMT</pubDate></item><item><title>Final layout decided, and a demo</title><link>http://openastronomy.org/Universe_OA/posts/2024/06/20240625_1759_kartikmandar/</link><dc:creator>Kartik Mandar</dc:creator><description>&lt;p&gt; So, the final layout was decided and I discussed with my mentors about the same. They liked it and suggested some changes. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhMa67MJ6HJ8F_bfsWuzC7Ro3aL6A-3PB6XfftMKYqVEAxhp6Y8JySOtBydtfw9xJf9lwOuDTPq4uZ0XcdnjIGug776Wuk312LYfB-hEC65hOom8w1zjJwzRNI6W9M-olE2hgKOHexVIEotXea-u7l9g_uuJuRJR1rVQ5_Sp49cqtpOyMP2t7_L32JSFA8p/s3840/B8E1879E-24A0-43AF-A58E-21FCB8A6474F.JPG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="298" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhMa67MJ6HJ8F_bfsWuzC7Ro3aL6A-3PB6XfftMKYqVEAxhp6Y8JySOtBydtfw9xJf9lwOuDTPq4uZ0XcdnjIGug776Wuk312LYfB-hEC65hOom8w1zjJwzRNI6W9M-olE2hgKOHexVIEotXea-u7l9g_uuJuRJR1rVQ5_Sp49cqtpOyMP2t7_L32JSFA8p/w530-h298/B8E1879E-24A0-43AF-A58E-21FCB8A6474F.JPG" width="530"&gt;&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;All these loading tabs should be made into one. And the structure should be more coherent. &lt;br&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;!-- TEASER_END --&gt;</description><category>stingray</category><guid>http://openastronomy.org/Universe_OA/posts/2024/06/20240625_1759_kartikmandar/</guid><pubDate>Tue, 25 Jun 2024 16:59:00 GMT</pubDate></item><item><title>Tackling the Challenges of Active Galactic Nuclei Data with Machine Learning Models</title><link>http://openastronomy.org/Universe_OA/posts/2024/06/20240623_2331_lucasmg18/</link><dc:creator>Lucas Martin Garcia</dc:creator><description>&lt;p&gt; &lt;strong&gt;Understanding the Complexity of AGN Light Curve Data&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Active Galactic Nuclei (AGNs) are among the most luminous and dynamic objects in the universe, characterized by their variable light emissions that provide key insights into the mechanics of galaxy evolution. A fundamental challenge in studying AGNs is the nature of the data collected where the parameters such as time and wavelength are critical. Each observation captures the light curve of an AGN.&lt;/p&gt;
&lt;p&gt;However, this data isn't straightforward. Observations are taken using different instruments, like different stations or satellites, leading to variations in data quality and measurement techniques. More critically, there are inevitable gaps in the data, caused by factors ranging from environmental conditions blocking observations to the simple fact that different tools have different operational time frames and capabilities.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;&lt;strong&gt;The Goal: Enhancing Data Cohesiveness&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The objective of our research project is clear: to enhance the cohesiveness and quality of AGN light curve datasets. This involves not only unifying data across different wavelengths and time periods but also filling in missing data to create a more complete picture of AGN activity. The challenge is non-trivial, as it requires sophisticated approaches to accurately interpolate or simulate missing observations without distorting the underlying physical phenomena.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Advanced Machine Learning Models for Data Enhancement&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;To address these challenges, we are exploring several machine learning (ML) models. Deep learning (DL) models, particularly neural networks, are at the forefront of our tools, owing to their ability to model complex patterns and dependencies in large datasets. Recurrent Neural Networks (RNNs) are particularly suited for this task because of their effectiveness in handling sequential data, which is a natural fit for time-series analysis like light curves.&lt;/p&gt;
&lt;p&gt;Moreover, Generative Adversarial Networks (GANs) offer a promising approach to generate new data points synthetically. GANs can be trained to produce data that mimics the statistical properties of existing observations, potentially filling gaps in the light curves with high accuracy. These models learn to simulate new data that could plausibly occur under similar conditions, based on the patterns learned from the data that do exist.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Moving Forward&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Our research is still in the developmental phase, with ongoing efforts to refine the models and enhance their predictive and generative capabilities. By integrating these advanced ML models, we aim to not only improve the data quality of AGN observations but also to provide deeper insights into their dynamic behavior, which remains an enigma in many aspects. This could significantly aid astronomers and astrophysicists in understanding the fundamental processes driving these powerful celestial objects.&lt;/p&gt;
&lt;p&gt;By leveraging the power of machine learning we hope to overcome the significant problems posed by the fragmented and incomplete nature of AGN light curve data. This research not only pushes the boundaries of astronomical data analysis but also contributes to the broader field of applied machine learning in solving real-world problems with high complexity and significant scientific impact.&lt;/p&gt;</description><category>irsa-fornax</category><guid>http://openastronomy.org/Universe_OA/posts/2024/06/20240623_2331_lucasmg18/</guid><pubDate>Sun, 23 Jun 2024 22:31:00 GMT</pubDate></item><item><title>It’s going good.</title><link>http://openastronomy.org/Universe_OA/posts/2024/06/20240623_0821_nucleongodx/</link><dc:creator>Manit Singh</dc:creator><description>&lt;p&gt;It’s going good.&lt;/p&gt;
&lt;p&gt;The past two weeks were dedicated to the implementation of wavelength functionality. Now, wavelength has been successfully implemented for the applicable instruments. Along with that, a how-to guide has been created to assist users in navigating querying over wavelength for different instruments. Additionally, a gallery example for wavelength and detector has been added.&lt;/p&gt;
&lt;h4&gt;What’s the direction of implementation:&lt;/h4&gt;&lt;p&gt;The implementation of wavelength can be divided into two parts:&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;Instruments with a “wavelength” column in SOAR&lt;/strong&gt;: These remote sensing instruments are EUI, SOLOHI, and METIS. For these instruments, we query on the basis of wavelength.&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt; instrument = a.Instrument("EUI")&lt;br&gt; time = a.Time("2023-04-03 15:00", "2023-04-03 16:00")&lt;br&gt; level = a.Level(1)&lt;br&gt; wavelength = a.Wavelength(304 * u.AA)&lt;br&gt; res = Fido.search(instrument &amp;amp; time &amp;amp; level &amp;amp; wavelength)&lt;/pre&gt;&lt;p&gt;Result:&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Ty2aSvBet-8KYDf6iE729w.png"&gt;&lt;/figure&gt;&lt;p&gt;A range of wavelength can also be passed, which will be considered wavemin and wavemax for these three instruments.&lt;/p&gt;
&lt;pre&gt;wavelength = a.Wavelength(171 * u.AA, 185 * u.AA)&lt;/pre&gt;&lt;p&gt;Result:&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*oUBJwth5UcL9IegFG5LjaA.png"&gt;&lt;/figure&gt;&lt;p&gt;2. For the instruments PHI and SPICE, we don’t have a “wavelength” column in their instrument table, so we use wavemin and wavemax for querying.&lt;/p&gt;
&lt;p&gt;However, there is a problem with SPICE. Since the range of wavelength is only given for the first spectral window of the data, to ensure the data is not misleading to the user, we do not return any wavelength values.&lt;/p&gt;
&lt;pre&gt; instrument = a.Instrument("PHI")&lt;br&gt; time = a.Time("2023-02-01", "2023-02-02")&lt;br&gt; level = a.Level(2)&lt;br&gt; wavelength = a.Wavelength(6173.065 * u.AA, 6173.501 * u.AA)&lt;br&gt; res = Fido.search(instrument &amp;amp; time &amp;amp; level &amp;amp; wavelength)&lt;/pre&gt;&lt;p&gt;Result:&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*fxkPK8p3KR6xMEv7zIkTXQ.png"&gt;&lt;/figure&gt;&lt;p&gt;Although passing a range of wavelengths is preferred for PHI, if only one value is passed, it will be taken as wavemin, and filtering will be done based on it. Additionally, the corresponding wavemax will be provided in the output table.&lt;/p&gt;
&lt;pre&gt;wavelength = a.Wavelength(6173.065 * u.AA)&lt;/pre&gt;&lt;p&gt;Result:&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*O-pETZd8HZi9qVt9NQGa-w.png"&gt;&lt;/figure&gt;&lt;h4&gt;Challenges that still needs working:&lt;/h4&gt;&lt;p&gt;There is an issue with PHI’s wavelength data as well. The wavelengths returned are sometimes in the order of 6173 and sometimes 617.3, which are essentially just different units of similar wavelength data, but this is not specified in SOAR.&lt;/p&gt;
&lt;img alt="" height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=160df7122684" width="1"&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2024/06/20240623_0821_nucleongodx/</guid><pubDate>Sun, 23 Jun 2024 07:21:59 GMT</pubDate></item><item><title>GSoC [Week 02-03] Progress</title><link>http://openastronomy.org/Universe_OA/posts/2024/06/20240623_0719_viciouseagle03/</link><dc:creator>ViciousEagle03</dc:creator><description>&lt;p&gt;This blog post covers all the work done in the second and third week of Google Summer of Code.&lt;/p&gt;
&lt;p&gt;In the past weeks, my focus has been on enhancing the serialization support of NDCube by extending its support for ExtraCoords and GlobalCoords. After establishing serialization support for the fundamental attributes of the NDCube object—such as data and wcs—in the ASDF file format, the next logical step was extending this capability to include &lt;code&gt;ExtraCoords&lt;/code&gt; and &lt;code&gt;GlobalCoords&lt;/code&gt; object.&lt;/p&gt;
&lt;h3 id="globalcoords-and-extracoords"&gt;GlobalCoords and ExtraCoords&lt;/h3&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;ExtraCoords: The ExtraCoords attribute expand NDCube’s capabilities by incorporating additional spatial or spectral coordinates beyond those defined by the primary WCS. It accommodate complex datasets needing extra dimensions or coordinates, such as spectroscopic data with folded axes.&lt;/p&gt;
&lt;p&gt;GlobalCoords: The GlobalCoords attribute are coordinates in an NDCube that provides universal context across the entire dataset and apply uniformly across all axes. It captures metadata such as observation times or global positional coordinates of the NDCube object.&lt;/p&gt;
&lt;h3 id="extending-the-serialization-support"&gt;Extending the Serialization support&lt;/h3&gt;
&lt;p&gt;Now, &lt;code&gt;ExtraCoords&lt;/code&gt; can be initialized by specifying a &lt;code&gt;BaseLowLevelWCS&lt;/code&gt; object and a mapping, or by building it up using one or more lookup tables. To support the latter method, I had to ensure the &lt;code&gt;lookup_tables&lt;/code&gt; were properly preserved during serialization. For this purpose, I designed the schema and wrote the converter class for the following objects:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ndcube.extra_coords.extra_coords.ExtraCoords&lt;/li&gt;
&lt;li&gt;ndcube.extra_coords.table_coord.TimeTableCoordinate&lt;/li&gt;
&lt;li&gt;ndcube.extra_coords.table_coord.QuantityTableCoordinate&lt;/li&gt;
&lt;li&gt;ndcube.extra_coords.table_coord.SkyCoordTableCoordinate&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The initialization of &lt;code&gt;GlobalCoords&lt;/code&gt; is more straightforward, which required me to design the schema and write the converter class for the following object:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ndcube.global_coords.GlobalCoords&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Here’s an example of the &lt;code&gt;ExtraCoords&lt;/code&gt; Schema&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;%YAML 1.1
---
$schema: "http://stsci.edu/schemas/yaml-schema/draft-01"
id: "asdf://sunpy.org/ndcube/schemas/extra_coords-0.1.0"

title:
Represents the ndcube ExtraCoords object

description:
Represents the ndcube ExtraCoords object

type: object
properties:
wcs:
tag: "tag:stsci.edu:gwcs/wcs-1.*"
mapping:
type: array
lookup_tables:
type: array
items:
type: array
items:
- oneOf:
- type: number
- type: array
- oneOf:
- tag: "tag:sunpy.org:ndcube/extra_coords/table_coord/quantitytablecoordinate-0.*"
- tag: "tag:sunpy.org:ndcube/extra_coords/table_coord/skycoordtablecoordinate-0.*"
- tag: "tag:sunpy.org:ndcube/extra_coords/table_coord/timetablecoordinate-0.*"
dropped_tables:
type: array
ndcube:
tag: "tag:sunpy.org:ndcube/ndcube/ndcube-0.*"

required: [ndcube]
additionalProperties: false
...
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="whats-new-keeping-up-with-the-coords"&gt;What’s new: Keeping Up with the Coords&lt;/h3&gt;
&lt;p&gt;&lt;img alt="img" src="https://viciouseagle03.github.io/images/ASDF-ser-new-type.png"&gt;&lt;/p&gt;
&lt;p&gt;Now, when we save an NDCube object to an ASDF file, the file successfully stores the &lt;code&gt;ExtraCoords&lt;/code&gt; and &lt;code&gt;GlobalCoords&lt;/code&gt; information, which is preserved when we deserialize and generate a new NDCube object by reading the file. The only thing that is still not supported is initializing an ExtraCoords object using a mapping and an &lt;code&gt;astropy.wcs.WCS&lt;/code&gt; object. This feature will be supported in the future when I implement serialization support for &lt;code&gt;astropy.wcs.WCS&lt;/code&gt; in the asdf-astropy library.&lt;/p&gt;
&lt;h5 id="saving-an-ndcube-with-globalcoords-and-extracoords-attribute"&gt;Saving an NDCube with &lt;code&gt;GlobalCoords&lt;/code&gt; and &lt;code&gt;ExtraCoords&lt;/code&gt; attribute&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;with asdf.open('ndcubeglobal_extra.asdf') as af:
ndcube2 = af.tree['ndcube']
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id="the-relevant-asdf-file-block"&gt;The relevant ASDF file block&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;extra_coords: !&amp;lt;tag:sunpy.org:ndcube/extra_coords/extra_coords/extracoords-0.1.0&amp;gt;
dropped_tables: []
lookup_tables:
- - 0
- !&amp;lt;tag:sunpy.org:ndcube/extra_coords/table_coord/timetablecoordinate-0.1.0&amp;gt;
mesh: false
names: [time]
reference_time: !time/time-1.1.0 {base_format: fits, value: '2000-01-01T00:00:00.000'}
table: !time/time-1.1.0
base_format: fits
value: !core/ndarray-1.0.0
byteorder: little
datatype: [ucs4, 23]
shape: [10]
source: 5
- - 0
- !&amp;lt;tag:sunpy.org:ndcube/extra_coords/table_coord/skycoordtablecoordinate-0.1.0&amp;gt;
mesh: false
names: [lon, lat]
table: !&amp;lt;tag:astropy.org:astropy/coordinates/skycoord-1.0.0&amp;gt;
dec: !&amp;lt;tag:astropy.org:astropy/coordinates/latitude-1.0.0&amp;gt;
unit: !unit/unit-1.0.0 deg
value: !core/ndarray-1.0.0
byteorder: little
datatype: float64
shape: [10]
source: 7
frame: icrs
ra: !&amp;lt;tag:astropy.org:astropy/coordinates/longitude-1.0.0&amp;gt;
unit: !unit/unit-1.0.0 deg
value: !core/ndarray-1.0.0
byteorder: little
datatype: float64
shape: [10]
source: 6
wrap_angle: !&amp;lt;tag:astropy.org:astropy/coordinates/angle-1.0.0&amp;gt; {datatype: float64,
unit: !unit/unit-1.0.0 deg, value: 360.0}
representation_type: spherical
- - 1
- !&amp;lt;tag:sunpy.org:ndcube/extra_coords/table_coord/quantitytablecoordinate-0.1.0&amp;gt;
mesh: true
names: [exposure_time]
table:
- !unit/quantity-1.1.0
unit: !unit/unit-1.0.0 s
value: !core/ndarray-1.0.0
byteorder: little
datatype: float64
shape: [10]
source: 8
unit: !unit/unit-1.0.0 s
ndcube: *id001
global_coords: !&amp;lt;tag:sunpy.org:ndcube/global_coords/globalcoords-0.1.0&amp;gt;
internal_coords:
name1:
- custom:physical_type1
- !unit/quantity-1.1.0 {datatype: float64, unit: !unit/unit-1.0.0 m, value: 1.0}
name2:
- custom:physical_type2
- !unit/quantity-1.1.0 {datatype: float64, unit: !unit/unit-1.0.0 s, value: 2.0}
ndcube: *id001
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;During my coding period, my mentors have been incredibly helpful, and huge thanks to &lt;a href="https://github.com/braingram"&gt;@braingram&lt;/a&gt; for explaining and ensuring I understood the entire ASDF serialization process thoroughly. I learned a lot about schema design and JSON schema. I was particularly impressed by the &lt;a href="https://docs.github.com/en/actions/using-workflows"&gt;CI workflows&lt;/a&gt;, when I set up a dedicated schema testing workflow. It showed me how automated testing can catch errors that manual testing might overlook. Although I implemented a straightforward workflow, it go me curious about learning more about CI workflows.&lt;/p&gt;
&lt;p&gt;I am currently adding tests for the new serialization support in NDCube, which I plan to finish by the next coding week.&lt;/p&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2024/06/20240623_0719_viciouseagle03/</guid><pubDate>Sun, 23 Jun 2024 06:19:36 GMT</pubDate></item></channel></rss>